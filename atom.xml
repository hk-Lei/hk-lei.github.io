<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苦行僧</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hk-lei.github.io/"/>
  <updated>2016-08-03T13:04:58.408Z</updated>
  <id>http://hk-lei.github.io/</id>
  
  <author>
    <name>hk Lei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Storm Flux</title>
    <link href="http://hk-lei.github.io/2016/07/15/storm-flux/"/>
    <id>http://hk-lei.github.io/2016/07/15/storm-flux/</id>
    <published>2016-07-15T14:30:50.000Z</published>
    <updated>2016-08-03T13:04:58.408Z</updated>
    
    <content type="html"><![CDATA[<p>一个用于简化 Apache Storm 流式计算任务创建和部署的框架</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>flux</strong> |fləks| <em>noun</em></p>
<ol>
<li>流入流出的动作或过程</li>
<li>持续变化</li>
<li>在物理学中，流体、辐射、微粒可以穿过一定的区域</li>
<li>与固体物质混合，用来降低熔点</li>
</ol>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>当配置是写死的时候总是会出现很多问题。不应该有人为了更改配置而重新编译或打包应用程序。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Flux 是一个用于简化创建和部署 Apache Storm Topologies 的框架和工具集。</p>
<a id="more"></a>
<p>你是不是发现你以前经常重复写如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 决定我们是不是在本地运行的逻辑...</span></div><div class="line">    <span class="comment">// 创建必要的配置项...</span></div><div class="line">    <span class="keyword">boolean</span> runLocal = shouldRunLocal();</div><div class="line">    <span class="keyword">if</span>(runLocal)&#123;</div><div class="line">        LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</div><div class="line">        cluster.submitTopology(name, conf, topology);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        StormSubmitter.submitTopology(name, conf, topology);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从来不会像这样简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">storm jar mytopology.jar org.apache.storm.flux.Flux --local config.yaml</div></pre></td></tr></table></figure>
<p>or:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">storm jar mytopology.jar org.apache.storm.flux.Flux --remote config.yaml</div></pre></td></tr></table></figure>
<p>另一个经常被提及的痛点：通常在 Java 代码中绑定 Topology 图，任何更改都需要重新编译和打包 Topology 的 jar 文件。Flux 旨在减轻这个痛点：通过将所有的 Storm 组件打包成一个 jar， 用一个额外的文本文件来定义 topologies 的布局和配置。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>不用在 Topology 的代码嵌入配置项，易于配置和部署 Storm topologies (包括 Storm 核心和微批 API)</li>
<li>支持已有的 topology 代码 （见下文）</li>
<li>使用一个灵活的 YAML DSL 定义 Storm 核心 API (Spouts/Bolts)</li>
<li>YAML DSL 支持大多数 Storm 组件 (storm-kafka, storm-hdfs, storm-hbase, 等等)</li>
<li>方便支持多语言的组件</li>
<li>外部属性替换/过滤，对于配置/环境环境之间轻松切换(类似于 Maven 的 <code>${variable.name}</code> 替换方式)</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用 Flux，需将其作为依赖打包到包含所有 Storm 组件的 fat jar 中，然后创建一个 YAML 文件来定义 topology 结构（参见下面的 YAML 配置项）。</p>
<h3 id="从源码构建"><a href="#从源码构建" class="headerlink" title="从源码构建"></a>从源码构建</h3><p>使用 Flux 最简单的方式是，如下所述将其作为一个 Maven 依赖添加到项目中。</p>
<p>如果你想从源代码构建 Flux 及运行单元/集成测试，则需要在系统中安装以下软件：</p>
<ul>
<li>Python 2.6.x or 或更高版本</li>
<li>Node.js 0.10.x or 或更高版本</li>
</ul>
<h4 id="构建中运行单元测试"><a href="#构建中运行单元测试" class="headerlink" title="构建中运行单元测试"></a>构建中运行单元测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clean install</div></pre></td></tr></table></figure>
<h4 id="构建中不运行单元测试"><a href="#构建中不运行单元测试" class="headerlink" title="构建中不运行单元测试"></a>构建中不运行单元测试</h4><p>如果想在构建 Flux 时不用安装 Python 或者 Node.js，你可以简单的跳过单元测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clean install -DskipTests=true</div></pre></td></tr></table></figure>
<p>注意：如果你计划使用 Flux 将 topologies 部署在远程集群上，那么仍然需要安装 Python，因为是 Apache Storm 必须的。</p>
<h4 id="构建中运行集成测试"><a href="#构建中运行集成测试" class="headerlink" title="构建中运行集成测试"></a>构建中运行集成测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clean install -DskipIntegration=false</div></pre></td></tr></table></figure>
<h3 id="Maven-打包"><a href="#Maven-打包" class="headerlink" title="Maven 打包"></a>Maven 打包</h3><p>为了在 Storm 组件中启用 Flux，需要将其添加为一个依赖，使得其包含在 Storm topology jar 中。可以使用 Maven shade 插件（首选）或者 Maven assembly 插件（不推荐）来完成。</p>
<h4 id="Flux-Maven-Dependency"><a href="#Flux-Maven-Dependency" class="headerlink" title="Flux Maven Dependency"></a>Flux Maven Dependency</h4><p>目前版本(译注：1.0.0)的 Flux 已经在 Maven 仓库中可用，坐标如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.storm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flux-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;storm.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="创建一个启用-Flux-的-Topology-JAR"><a href="#创建一个启用-Flux-的-Topology-JAR" class="headerlink" title="创建一个启用 Flux 的 Topology JAR"></a>创建一个启用 Flux 的 Topology JAR</h4><p>下面的例子演示了通过 Maven shade 插件使用 Flux：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 在 shaded jar 中引入 Flux 和用户依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 引入 Flux --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.storm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flux-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;storm.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 在这里添加用户依赖... --&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 创建一个包含所有依赖的 jar --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">createDependencyReducedPom</span>&gt;</span>true<span class="tag">&lt;/<span class="name">createDependencyReducedPom</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">transformer</span></span></div><div class="line">                                    <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer"</span>/&gt;</div><div class="line">                            <span class="tag">&lt;<span class="name">transformer</span></span></div><div class="line">                                    <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</div><div class="line">                                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>org.apache.storm.flux.Flux<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="部署运行-Flux-Topology"><a href="#部署运行-Flux-Topology" class="headerlink" title="部署运行 Flux Topology"></a>部署运行 Flux Topology</h3><p>一旦 topology 组件和 Flux 依赖打包到一起，就可以通过 <code>storm jar</code> 命令在本地或者远程运行不同的 topologies。例如：假设 jar 包叫 <code>myTopology-0.1.0-SNAPSHOT.jar</code>，可以使用下述命令在本地运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">storm jar myTopology-0.1.0-SNAPSHOT.jar org.apache.storm.flux.Flux --local my_config.yaml</div></pre></td></tr></table></figure>
<h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">usage: storm jar &lt;my_topology_uber_jar.jar&gt; org.apache.storm.flux.Flux</div><div class="line">             [options] &lt;topology-config.yaml&gt;</div><div class="line"> -d,--dry-run                 Do not run or deploy the topology. Just</div><div class="line">                              build, validate, and print information about</div><div class="line">                              the topology.</div><div class="line"> -e,--env-filter              Perform environment variable substitution.</div><div class="line">                              Replace keys identified with `$&#123;ENV-[NAME]&#125;`</div><div class="line">                              will be replaced with the corresponding</div><div class="line">                              `NAME` environment value</div><div class="line"> -f,--filter &lt;file&gt;           Perform property substitution. Use the</div><div class="line">                              specified file as a source of properties,</div><div class="line">                              and replace keys identified with &#123;$[property</div><div class="line">                              name]&#125; with the value defined in the</div><div class="line">                              properties file.</div><div class="line"> -i,--inactive                Deploy the topology, but do not activate it.</div><div class="line"> -l,--local                   Run the topology in local mode.</div><div class="line"> -n,--no-splash               Suppress the printing of the splash screen.</div><div class="line"> -q,--no-detail               Suppress the printing of topology details.</div><div class="line"> -r,--remote                  Deploy the topology to a remote cluster.</div><div class="line"> -R,--resource                Treat the supplied path as a classpath</div><div class="line">                              resource instead of a file.</div><div class="line"> -s,--sleep &lt;ms&gt;              When running locally, the amount of time to</div><div class="line">                              sleep (in ms.) before killing the topology</div><div class="line">                              and shutting down the local cluster.</div><div class="line"> -z,--zookeeper &lt;host:port&gt;   When running in local mode, use the</div><div class="line">                              ZooKeeper at the specified &lt;host&gt;:&lt;port&gt;</div><div class="line">                              instead of the in-process ZooKeeper.</div><div class="line">                              (requires Storm 0.9.3 or later)</div></pre></td></tr></table></figure>
<p><strong>注意:</strong> Flux 努力避免与 <code>storm</code> 命令行的冲突，允许使用 <code>storm</code> 命令的其他任何命令选项。</p>
<p>例如：你可以使用 <code>storm</code> 命令的 -c 选项去覆盖 topology 的配置项。下述示例命令将运行 Flux 并且覆盖 <code>nimbus.seeds</code> 配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">storm jar myTopology-0.1.0-SNAPSHOT.jar org.apache.storm.flux.Flux --remote my_config.yaml -c <span class="string">'nimbus.seeds=["localhost"]'</span></div></pre></td></tr></table></figure>
<h3 id="简单的输出"><a href="#简单的输出" class="headerlink" title="简单的输出"></a>简单的输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">███████╗██╗     ██╗   ██╗██╗  ██╗</div><div class="line">██╔════╝██║     ██║   ██║╚██╗██╔╝</div><div class="line">█████╗  ██║     ██║   ██║ ╚███╔╝</div><div class="line">██╔══╝  ██║     ██║   ██║ ██╔██╗</div><div class="line">██║     ███████╗╚██████╔╝██╔╝ ██╗</div><div class="line">╚═╝     ╚══════╝ ╚═════╝ ╚═╝  ╚═╝</div><div class="line">+-         Apache Storm        -+</div><div class="line">+-  data FLow User eXperience  -+</div><div class="line">Version: 0.3.0</div><div class="line">Parsing file: /Users/hsimpson/Projects/donut_domination/storm/shell_test.yaml</div><div class="line">---------- TOPOLOGY DETAILS ----------</div><div class="line">Name: shell-topology</div><div class="line">--------------- SPOUTS ---------------</div><div class="line">sentence-spout[1](org.apache.storm.flux.spouts.GenericShellSpout)</div><div class="line">---------------- BOLTS ---------------</div><div class="line">splitsentence[1](org.apache.storm.flux.bolts.GenericShellBolt)</div><div class="line">log[1](org.apache.storm.flux.wrappers.bolts.LogInfoBolt)</div><div class="line">count[1](org.apache.storm.testing.TestWordCounter)</div><div class="line">--------------- STREAMS ---------------</div><div class="line">sentence-spout --SHUFFLE--&gt; splitsentence</div><div class="line">splitsentence --FIELDS--&gt; count</div><div class="line">count --SHUFFLE--&gt; log</div><div class="line">--------------------------------------</div><div class="line">Submitting topology: &apos;shell-topology&apos; to remote cluster...</div></pre></td></tr></table></figure>
<h2 id="YAML-配置项"><a href="#YAML-配置项" class="headerlink" title="YAML 配置项"></a>YAML 配置项</h2><p>在 YAML 文件中定义（或描述） Flux topology，一个 Flux topology 由以下部件组成：</p>
<ol>
<li>一个 topology 名称</li>
<li>topology 的 “组件(components)” 列表(将在环境中可用的 Java 对象)</li>
<li><strong>EITHER</strong> (DSL topology 定义):<ul>
<li>spouts 列表，每个需要一个唯一的 ID 标识</li>
<li>bolts 列表，每个需要一个唯一的 ID 标识</li>
<li>“stream” 列表，代表了在 spouts 和 bolts 间传输的 tuples 流</li>
</ul>
</li>
<li><strong>OR</strong> (可用产生 <code>org.apache.storm.generated.StormTopology</code> 实例的 JVM 类):<ul>
<li>一个 <code>topologySource</code> 定义.</li>
</ul>
</li>
</ol>
<p><strong>译注：</strong> 3、4 二选一。</p>
<p>例如，这有一个使用 YAML DSL 简单定义的单词统计的 topology：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="attr">name:</span> <span class="string">"yaml-topology"</span></div><div class="line"><span class="attr">config:</span></div><div class="line">  topology.workers: <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment"># 定义 spouts</span></div><div class="line"><span class="attr">spouts:</span></div><div class="line"><span class="attr">  - id:</span> <span class="string">"spout-1"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.testing.TestWordSpout"</span></div><div class="line"><span class="attr">    parallelism:</span> <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment"># 定义 bolts</span></div><div class="line"><span class="attr">bolts:</span></div><div class="line"><span class="attr">  - id:</span> <span class="string">"bolt-1"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.testing.TestWordCounter"</span></div><div class="line"><span class="attr">    parallelism:</span> <span class="number">1</span></div><div class="line"><span class="attr">  - id:</span> <span class="string">"bolt-2"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.flux.wrappers.bolts.LogInfoBolt"</span></div><div class="line"><span class="attr">    parallelism:</span> <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment"># 定义数据流</span></div><div class="line"><span class="attr">streams:</span></div><div class="line"><span class="attr">  - name:</span> <span class="string">"spout-1 --&gt; bolt-1"</span> <span class="comment"># 名称目前没有被使用 (logging、UI 等的占位符)</span></div><div class="line"><span class="attr">    from:</span> <span class="string">"spout-1"</span></div><div class="line"><span class="attr">    to:</span> <span class="string">"bolt-1"</span></div><div class="line"><span class="attr">    grouping:</span></div><div class="line"><span class="attr">      type:</span> FIELDS</div><div class="line"><span class="attr">      args:</span> [<span class="string">"word"</span>]</div><div class="line"></div><div class="line"><span class="attr">  - name:</span> <span class="string">"bolt-1 --&gt; bolt2"</span></div><div class="line"><span class="attr">    from:</span> <span class="string">"bolt-1"</span></div><div class="line"><span class="attr">    to:</span> <span class="string">"bolt-2"</span></div><div class="line"><span class="attr">    grouping:</span></div><div class="line"><span class="attr">      type:</span> SHUFFLE</div></pre></td></tr></table></figure>
<h2 id="替换-过滤属性"><a href="#替换-过滤属性" class="headerlink" title="替换/过滤属性"></a>替换/过滤属性</h2><p>通常开发者希望在不同配置之间切换自如，例如在开发环境和生产环境间的切换部署。这个可以使用不同的 YAML 配置文件来完成，但是这种方法导致了不必要的重复，尤其是在 Storm topology 没有改变的情况下，改变主机名、端口和并行度等配置。</p>
<p>在这种情况下，Flux 提供了属性过滤允许将不同的值外部化到不同的 <code>.properties</code> 文件中，在解析 <code>.yaml</code> 文件前替换他们。</p>
<p>使用 <code>--filter</code> 命令选项来启用属性过滤。例如，可以这样调用 Flux：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">storm jar myTopology-0.1.0-SNAPSHOT.jar org.apache.storm.flux.Flux --local my_config.yaml --filter dev.properties</div></pre></td></tr></table></figure>
<p>使用如下的 <code>dev.properties</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kafka.zookeeper.hosts: localhost:2181</div></pre></td></tr></table></figure>
<p>可以在 <code>.yaml</code> 文件中使用 <code>${}</code> 语法通过 key 引用那些属性值：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- id:</span> <span class="string">"zkHosts"</span></div><div class="line"><span class="attr">  className:</span> <span class="string">"org.apache.storm.kafka.ZkHosts"</span></div><div class="line"><span class="attr">  constructorArgs:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">"$&#123;kafka.zookeeper.hosts&#125;"</span></div></pre></td></tr></table></figure>
<p>这样，在解析 YAML 内容之前 Flux 将使用 <code>localhost:2181</code> 替换 <code>${kafka.zookeeper.hosts}</code>。</p>
<h3 id="替换-过滤环境变量"><a href="#替换-过滤环境变量" class="headerlink" title="替换/过滤环境变量"></a>替换/过滤环境变量</h3><p>Flux 也运行替换环境变量。例如，定义了一个环境变量名为 <code>ZK_HOSTS</code>，可以在 Flux YAML 中用如下的语法引用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$&#123;ENV-ZK_HOSTS&#125;</div></pre></td></tr></table></figure>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件实质上是配置项中的 spouts 和 bolts 对象实例，如果熟悉 Spring 框架的话，组件可以类比 Spring beans。</p>
<p>每个组件至少有一个唯一的标识符（字符串）和类名(字符串)标识。例如，以下将创建一个 <code>org.apache.storm.kafka.StringScheme</code> 类的实例作为键 <code>&quot;stringScheme&quot;</code> 的引用，假设 <code>org.apache.storm.kafka.StringScheme</code> 类有一个默认的构造方法。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">components:</span></div><div class="line"><span class="attr">  - id:</span> <span class="string">"stringScheme"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.kafka.StringScheme"</span></div></pre></td></tr></table></figure>
<h3 id="构造参数、引用、属性和配置方法"><a href="#构造参数、引用、属性和配置方法" class="headerlink" title="构造参数、引用、属性和配置方法"></a>构造参数、引用、属性和配置方法</h3><h4 id="构造参数"><a href="#构造参数" class="headerlink" title="构造参数"></a>构造参数</h4><p>可以通过在组件中添加一个 <code>contructorArgs</code> 元素来配置组件类构造方法的参数。 <code>contructorArgs</code> 是一个传递给类的构造函数的对象列表。下面示例中通过调用接收一个字符串的构造函数创建了一个对象。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- id:</span> <span class="string">"zkHosts"</span></div><div class="line"><span class="attr">  className:</span> <span class="string">"org.apache.storm.kafka.ZkHosts"</span></div><div class="line"><span class="attr">  constructorArgs:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">"localhost:2181"</span></div></pre></td></tr></table></figure>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>每个组件示例是由一个唯一的 id 标识的，其允许被其他组件使用/重用。引用现有的组件，需要使用 <code>ref</code> 标签指定组件的 id。</p>
<p>在下例中，创建了一个 id 为 <code>&quot;stringScheme&quot;</code> 的组件，然后作为另一个组件构造方法的参数被引用。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attr">components:</span></div><div class="line"><span class="attr">  - id:</span> <span class="string">"stringScheme"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.kafka.StringScheme"</span></div><div class="line"></div><div class="line"><span class="attr">  - id:</span> <span class="string">"stringMultiScheme"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.spout.SchemeAsMultiScheme"</span></div><div class="line"><span class="attr">    constructorArgs:</span></div><div class="line"><span class="attr">      - ref:</span> <span class="string">"stringScheme"</span> <span class="comment"># id 为 "stringScheme" 的组件必须在上面已经声明了</span></div></pre></td></tr></table></figure>
<p><strong>注意:</strong> 引用只能在被声明的对象下面使用。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>除了支持调用不同参数的构造方法之外，Flux 还允许使用类似 JavaBean 的 setter 方法来配置组件，字段需声明为 <code>public</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- id:</span> <span class="string">"spoutConfig"</span></div><div class="line"><span class="attr">  className:</span> <span class="string">"org.apache.storm.kafka.SpoutConfig"</span></div><div class="line"><span class="attr">  constructorArgs:</span></div><div class="line">    <span class="comment"># brokerHosts</span></div><div class="line"><span class="attr">    - ref:</span> <span class="string">"zkHosts"</span></div><div class="line">    <span class="comment"># topic</span></div><div class="line"><span class="bullet">    -</span> <span class="string">"myKafkaTopic"</span></div><div class="line">    <span class="comment"># zkRoot</span></div><div class="line"><span class="bullet">    -</span> <span class="string">"/kafkaSpout"</span></div><div class="line">    <span class="comment"># id</span></div><div class="line"><span class="bullet">    -</span> <span class="string">"myId"</span></div><div class="line"><span class="attr">  properties:</span></div><div class="line"><span class="attr">    - name:</span> <span class="string">"ignoreZkOffsets"</span></div><div class="line"><span class="attr">      value:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    - name:</span> <span class="string">"scheme"</span></div><div class="line"><span class="attr">      ref:</span> <span class="string">"stringMultiScheme"</span></div></pre></td></tr></table></figure>
<p>在上述示例中，<code>properties</code> 声明会致使 Flux 在 <code>SpoutConfig</code> 中去寻找一个 public 方法 <code>setForceFromStart(boolean b)</code> 并尝试调用它。如果 setter 方法没找到，Flux 会再去寻找一个名为 <code>ignoreZkOffsets</code> 的 public 实例变量并尝试设置其值。</p>
<p>引用也可以作为属性的值。</p>
<h4 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h4><p>从概念上讲，配置方法类似于属性和构造参数 – 他们允许你在一个对象被构造后调用一个任意的方法。配置方法对于处理类是很有用的，不用暴露 JavaBean 方法和构造器就可以完全配置一个对象。常见的例子包括类都使用建造者模式 (<code>builder pattern</code>) 配置/构成。</p>
<p>下述的 YAML 示例创建了一个 bolt 并配置其调用一些方法：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="attr">bolts:</span></div><div class="line"><span class="attr">  - id:</span> <span class="string">"bolt-1"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.flux.test.TestBolt"</span></div><div class="line"><span class="attr">    parallelism:</span> <span class="number">1</span></div><div class="line"><span class="attr">    configMethods:</span></div><div class="line"><span class="attr">      - name:</span> <span class="string">"withFoo"</span></div><div class="line"><span class="attr">        args:</span></div><div class="line"><span class="bullet">          -</span> <span class="string">"foo"</span></div><div class="line"><span class="attr">      - name:</span> <span class="string">"withBar"</span></div><div class="line"><span class="attr">        args:</span></div><div class="line"><span class="bullet">          -</span> <span class="string">"bar"</span></div><div class="line"><span class="attr">      - name:</span> <span class="string">"withFooBar"</span></div><div class="line"><span class="attr">        args:</span></div><div class="line"><span class="bullet">          -</span> <span class="string">"foo"</span></div><div class="line"><span class="bullet">          -</span> <span class="string">"bar"</span></div></pre></td></tr></table></figure>
<p>相应的方法声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withFoo</span><span class="params">(String foo)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withBar</span><span class="params">(String bar)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withFooBar</span><span class="params">(String foo, String bar)</span></span>;</div></pre></td></tr></table></figure>
<p>传递给配置方法的参数同构造函数参数工作方式相同，也支持引用。</p>
<h3 id="在构造参数、引用、属性和配置方法中使用-Java-枚举-enum"><a href="#在构造参数、引用、属性和配置方法中使用-Java-枚举-enum" class="headerlink" title="在构造参数、引用、属性和配置方法中使用 Java 枚举 (enum)"></a>在构造参数、引用、属性和配置方法中使用 Java 枚举 (<code>enum</code>)</h3><p>在 Flux YAML 文件中可以很容易的使用 Java 枚举的值作为参数，只需引用 <code>enum</code> 即可。</p>
<p>例如，<a href="">Storm 的 HDFS 模块</a> 包含以下枚举定义（简写）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> Units &#123;</div><div class="line">    KB, MB, GB, TB</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>org.apache.storm.hdfs.bolt.rotation.FileSizeRotationPolicy</code> 类有如下的构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSizeRotationPolicy</span><span class="params">(<span class="keyword">float</span> count, Units units)</span></span></div></pre></td></tr></table></figure>
<p>下面的 Flux <code>component</code> 定义可以被用来调用构造函数:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- id:</span> <span class="string">"rotationPolicy"</span></div><div class="line"><span class="attr">  className:</span> <span class="string">"org.apache.storm.hdfs.bolt.rotation.FileSizeRotationPolicy"</span></div><div class="line"><span class="attr">  constructorArgs:</span></div><div class="line"><span class="bullet">    -</span> <span class="number">5.0</span></div><div class="line"><span class="bullet">    -</span> MB</div></pre></td></tr></table></figure>
<p>上述定义的功能相当于如下的 Java 代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当文件达到 5 MB 时切文件</span></div><div class="line">FileRotationPolicy rotationPolicy = <span class="keyword">new</span> FileSizeRotationPolicy(<span class="number">5.0f</span>, Units.MB);</div></pre></td></tr></table></figure>
<h2 id="配置-Topology"><a href="#配置-Topology" class="headerlink" title="配置 Topology"></a>配置 Topology</h2><p><code>config</code> 部分是 Storm topology 配置参数中的一个简单的键值对，其将被作为 <code>org.apache.storm.Config</code> 类的示例传递给 <code>org.apache.storm.StormSubmitter</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">config:</span></div><div class="line">  topology.workers: <span class="number">4</span></div><div class="line">  topology.max.spout.pending: <span class="number">1000</span></div><div class="line">  topology.message.timeout.secs: <span class="number">30</span></div></pre></td></tr></table></figure>
<h2 id="已存在的-Topologies"><a href="#已存在的-Topologies" class="headerlink" title="已存在的 Topologies"></a>已存在的 Topologies</h2><p>如果你有已存在的 Storm topologies，你也可以使用 Flux 来部署/运行/测试它们。这个特性允许你为现有的 topology 利用 Flux 构造函数参数、引用、属性和 Topology 配置声明。</p>
<p>使用现有的 topology 类最简单的方法是定义一个如下的 <code>getTopology()</code> 的实例方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> StormTopology <span class="title">getTopology</span><span class="params">(Map&lt;String, Object&gt; config)</span></span></div></pre></td></tr></table></figure>
<p>或:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> StormTopology <span class="title">getTopology</span><span class="params">(Config config)</span></span></div></pre></td></tr></table></figure>
<p>可以使用如下的 YAML 来配置 topology：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">name:</span> <span class="string">"existing-topology"</span></div><div class="line"><span class="attr">topologySource:</span></div><div class="line"><span class="attr">  className:</span> <span class="string">"org.apache.storm.flux.test.SimpleTopology"</span></div></pre></td></tr></table></figure>
<p>如果你想使用的 topology 类中有不同的方法名(即不是 <code>getTopology</code>)，你可以重写它:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">name:</span> <span class="string">"existing-topology"</span></div><div class="line"><span class="attr">topologySource:</span></div><div class="line"><span class="attr">  className:</span> <span class="string">"org.apache.storm.flux.test.SimpleTopology"</span></div><div class="line"><span class="attr">  methodName:</span> <span class="string">"getTopologyWithDifferentMethodName"</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong> 这个指定的方法必须接受一个 <code>java.util.Map&lt;String, Object&gt;</code> 或<br><code>org.apache.storm.Config</code> 类型的参数，返回一个 <code>org.apache.storm.generated.StormTopology</code> 对象。</p>
<h2 id="YAML-DSL"><a href="#YAML-DSL" class="headerlink" title="YAML DSL"></a>YAML DSL</h2><h3 id="Spouts-和-Bolts"><a href="#Spouts-和-Bolts" class="headerlink" title="Spouts 和 Bolts"></a>Spouts 和 Bolts</h3><p>YAML 配置中，Spout 和 Bolt 分别在他们自己的配置项中。<code>component</code> 的定义由 Spout 和 Bolt 的定义组成，通过添加 <code>parallelism</code> 参数来设置部署 topology 时组件的并行度。</p>
<p>由于 spout 和 bolt 的定义继承自 <code>component</code>，所以他们也支持构造函数参数、引用和属性。</p>
<p>Shell spout 示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spouts:</span></div><div class="line"><span class="attr">  - id:</span> <span class="string">"sentence-spout"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.flux.spouts.GenericShellSpout"</span></div><div class="line">    <span class="comment"># shell spout 的构造函数需要 2 个参数: String[], String[]</span></div><div class="line"><span class="attr">    constructorArgs:</span></div><div class="line">      <span class="comment"># 命令行</span></div><div class="line"><span class="bullet">      -</span> [<span class="string">"node"</span>, <span class="string">"randomsentence.js"</span>]</div><div class="line">      <span class="comment"># 输出 fields</span></div><div class="line"><span class="bullet">      -</span> [<span class="string">"word"</span>]</div><div class="line"><span class="attr">    parallelism:</span> <span class="number">1</span></div></pre></td></tr></table></figure>
<p>Kafka spout 示例:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="attr">components:</span></div><div class="line"><span class="attr">  - id:</span> <span class="string">"stringScheme"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.kafka.StringScheme"</span></div><div class="line"></div><div class="line"><span class="attr">  - id:</span> <span class="string">"stringMultiScheme"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.spout.SchemeAsMultiScheme"</span></div><div class="line"><span class="attr">    constructorArgs:</span></div><div class="line"><span class="attr">      - ref:</span> <span class="string">"stringScheme"</span></div><div class="line"></div><div class="line"><span class="attr">  - id:</span> <span class="string">"zkHosts"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.kafka.ZkHosts"</span></div><div class="line"><span class="attr">    constructorArgs:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"localhost:2181"</span></div><div class="line"></div><div class="line"><span class="comment"># 可选的 kafka 配置</span></div><div class="line"><span class="comment">#  - id: "kafkaConfig"</span></div><div class="line"><span class="comment">#    className: "org.apache.storm.kafka.KafkaConfig"</span></div><div class="line"><span class="comment">#    constructorArgs:</span></div><div class="line"><span class="comment">#      # brokerHosts</span></div><div class="line"><span class="comment">#      - ref: "zkHosts"</span></div><div class="line"><span class="comment">#      # topic</span></div><div class="line"><span class="comment">#      - "myKafkaTopic"</span></div><div class="line"><span class="comment">#      # clientId (可选)</span></div><div class="line"><span class="comment">#      - "myKafkaClientId"</span></div><div class="line"></div><div class="line"><span class="attr">  - id:</span> <span class="string">"spoutConfig"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.kafka.SpoutConfig"</span></div><div class="line"><span class="attr">    constructorArgs:</span></div><div class="line">      <span class="comment"># brokerHosts</span></div><div class="line"><span class="attr">      - ref:</span> <span class="string">"zkHosts"</span></div><div class="line">      <span class="comment"># topic</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"myKafkaTopic"</span></div><div class="line">      <span class="comment"># zkRoot</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"/kafkaSpout"</span></div><div class="line">      <span class="comment"># id</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"myId"</span></div><div class="line"><span class="attr">    properties:</span></div><div class="line"><span class="attr">      - name:</span> <span class="string">"ignoreZkOffsets"</span></div><div class="line"><span class="attr">        value:</span> <span class="literal">true</span></div><div class="line"><span class="attr">      - name:</span> <span class="string">"scheme"</span></div><div class="line"><span class="attr">        ref:</span> <span class="string">"stringMultiScheme"</span></div><div class="line"></div><div class="line"><span class="attr">config:</span></div><div class="line">  topology.workers: <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment"># 定义 spout</span></div><div class="line"><span class="attr">spouts:</span></div><div class="line"><span class="attr">  - id:</span> <span class="string">"kafka-spout"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.kafka.KafkaSpout"</span></div><div class="line"><span class="attr">    constructorArgs:</span></div><div class="line"><span class="attr">      - ref:</span> <span class="string">"spoutConfig"</span></div></pre></td></tr></table></figure>
<p>Bolt 示例:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义 bolt</span></div><div class="line"><span class="attr">bolts:</span></div><div class="line"><span class="attr">  - id:</span> <span class="string">"splitsentence"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.flux.bolts.GenericShellBolt"</span></div><div class="line"><span class="attr">    constructorArgs:</span></div><div class="line">      <span class="comment"># 命令行</span></div><div class="line"><span class="bullet">      -</span> [<span class="string">"python"</span>, <span class="string">"splitsentence.py"</span>]</div><div class="line">      <span class="comment"># 输出 fields</span></div><div class="line"><span class="bullet">      -</span> [<span class="string">"word"</span>]</div><div class="line"><span class="attr">    parallelism:</span> <span class="number">1</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line"><span class="attr">  - id:</span> <span class="string">"log"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.flux.wrappers.bolts.LogInfoBolt"</span></div><div class="line"><span class="attr">    parallelism:</span> <span class="number">1</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line"><span class="attr">  - id:</span> <span class="string">"count"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.testing.TestWordCounter"</span></div><div class="line"><span class="attr">    parallelism:</span> <span class="number">1</span></div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure>
<h3 id="流和分组"><a href="#流和分组" class="headerlink" title="流和分组"></a>流和分组</h3><p>Flux 中的流可以被描绘成 Topology 中 Spouts 和 Bolts 间的一系列连接 (图的边、数据流等)，其有一个相应的分组定义。</p>
<p>流定义包含下列属性：</p>
<p><strong><code>name</code>:</strong> 连接的名称(可选，目前未使用)</p>
<p><strong><code>from</code>:</strong> Spout 或 Bolt 源(发布者)的 <code>id</code></p>
<p><strong><code>to</code>:</strong> Spout 或 Bolt 目的地(订阅者)的 <code>id</code></p>
<p><strong><code>grouping</code>:</strong> 流分组定义</p>
<p>分组定义包含下列属性：</p>
<p><strong><code>type</code>:</strong> 分组类型： <code>ALL</code>、<code>CUSTOM</code>、<code>DIRECT</code>、<code>SHUFFLE</code>、<code>LOCAL_OR_SHUFFLE</code>、<code>FIELDS</code>、<code>GLOBAL</code> 或 <code>NONE</code>其中之一。</p>
<p><strong><code>streamId</code>:</strong> Storm 流 ID (可选。如果没指明将使用默认的 default )</p>
<p><strong><code>args</code>:</strong> 面向 <code>FIELDS</code> 分组的字段名列表。</p>
<p><strong><code>customClass</code></strong> 面向 <code>CUSTOM</code> 分组的自定义分组类。</p>
<p>下例中的 <code>streams</code> 定义使用如下的连接建立了一个 Topology：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kafka-spout --&gt; splitsentence --&gt; count --&gt; log</div></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 流定义</span></div><div class="line"><span class="comment"># 流定义就是定义 spouts 和 bolts 之间的连接</span></div><div class="line"><span class="comment"># 注意这种连接可以是周期性的</span></div><div class="line"><span class="comment"># 自定义流分组也是支持的</span></div><div class="line"></div><div class="line"><span class="attr">streams:</span></div><div class="line"><span class="attr">  - name:</span> <span class="string">"kafka --&gt; split"</span> <span class="comment"># 名称目前没有被使用 (logging、UI 等的占位符)</span></div><div class="line"><span class="attr">    from:</span> <span class="string">"kafka-spout"</span></div><div class="line"><span class="attr">    to:</span> <span class="string">"splitsentence"</span></div><div class="line"><span class="attr">    grouping:</span></div><div class="line"><span class="attr">      type:</span> SHUFFLE</div><div class="line"></div><div class="line"><span class="attr">  - name:</span> <span class="string">"split --&gt; count"</span></div><div class="line"><span class="attr">    from:</span> <span class="string">"splitsentence"</span></div><div class="line"><span class="attr">    to:</span> <span class="string">"count"</span></div><div class="line"><span class="attr">    grouping:</span></div><div class="line"><span class="attr">      type:</span> FIELDS</div><div class="line"><span class="attr">      args:</span> [<span class="string">"word"</span>]</div><div class="line"></div><div class="line"><span class="attr">  - name:</span> <span class="string">"count --&gt; log"</span></div><div class="line"><span class="attr">    from:</span> <span class="string">"count"</span></div><div class="line"><span class="attr">    to:</span> <span class="string">"log"</span></div><div class="line"><span class="attr">    grouping:</span></div><div class="line"><span class="attr">      type:</span> SHUFFLE</div></pre></td></tr></table></figure>
<h4 id="自定义流分组"><a href="#自定义流分组" class="headerlink" title="自定义流分组"></a>自定义流分组</h4><p>自定义流分组的定义通过设置分组类型为 <code>CUSTOM</code> 和定义一个 <code>customClass</code> 参数，告诉 Flux 如何自定义类实例化。<code>customClass</code> 定义继承自 <code>component</code>，所以它也支持构造函数参数、引用和属性。</p>
<p>下例中使用了一个自定义流分组类 <code>org.apache.storm.testing.NGrouping</code> 创建了一个流：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- name:</span> <span class="string">"bolt-1 --&gt; bolt2"</span></div><div class="line"><span class="attr">  from:</span> <span class="string">"bolt-1"</span></div><div class="line"><span class="attr">  to:</span> <span class="string">"bolt-2"</span></div><div class="line"><span class="attr">  grouping:</span></div><div class="line"><span class="attr">    type:</span> CUSTOM</div><div class="line"><span class="attr">    customClass:</span></div><div class="line"><span class="attr">      className:</span> <span class="string">"org.apache.storm.testing.NGrouping"</span></div><div class="line"><span class="attr">      constructorArgs:</span></div><div class="line"><span class="bullet">        -</span> <span class="number">1</span></div></pre></td></tr></table></figure>
<h3 id="Includes-和-Overrides"><a href="#Includes-和-Overrides" class="headerlink" title="Includes 和 Overrides"></a>Includes 和 Overrides</h3><p>Flux 允许包含其他的 YAML 文件，就像在同一个文件中定义一样。包含的可以是文件，也可以是 classpath 资源。</p>
<p>Includes 指定为一个键值对列表:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">includes:</span></div><div class="line"><span class="attr">  - resource:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    file:</span> <span class="string">"src/test/resources/configs/shell_test.yaml"</span></div><div class="line"><span class="attr">    override:</span> <span class="literal">false</span></div></pre></td></tr></table></figure>
<p>如果 <code>resource</code> 属性设置为 <code>true</code>，通过 <code>file</code> 属性的值将加载 classpath 资源，否则其将被视为一个正常的文件。</p>
<p><code>override</code> 属性控制如何有效的包含在当前文件中定义的值。如果 <code>override</code> 设置为 <code>true</code>, 解析时 <code>file</code> 文件中包含的值将会替换当前文件中的值； <code>override</code> 设置为 <code>false</code>, 当前文件中的值的解析优先级高，解析器将拒绝替换他们。</p>
<p><strong>注意:</strong> Includes 目前还不是递归的，包含文件中的 Includes 将会被忽略。</p>
<h3 id="Word-Count-示例"><a href="#Word-Count-示例" class="headerlink" title="Word Count 示例"></a>Word Count 示例</h3><p>这个示例使用里一个 JavaScript 实现的 spout、一个 Python 实现的 bolt、和一个 Java 实现的 bolt。</p>
<p>Topology YAML 配置:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">---</span></div><div class="line"><span class="attr">name:</span> <span class="string">"shell-topology"</span></div><div class="line"><span class="attr">config:</span></div><div class="line">  topology.workers: <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment"># 定义 spout</span></div><div class="line"><span class="attr">spouts:</span></div><div class="line"><span class="attr">  - id:</span> <span class="string">"sentence-spout"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.flux.spouts.GenericShellSpout"</span></div><div class="line">    <span class="comment"># shell spout 的构造函数需要 2 个参数: String[], String[]</span></div><div class="line"><span class="attr">    constructorArgs:</span></div><div class="line">      <span class="comment"># 命令行</span></div><div class="line"><span class="bullet">      -</span> [<span class="string">"node"</span>, <span class="string">"randomsentence.js"</span>]</div><div class="line">      <span class="comment"># 输出 fields</span></div><div class="line"><span class="bullet">      -</span> [<span class="string">"word"</span>]</div><div class="line"><span class="attr">    parallelism:</span> <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment"># 定义 bolt</span></div><div class="line"><span class="attr">bolts:</span></div><div class="line"><span class="attr">  - id:</span> <span class="string">"splitsentence"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.flux.bolts.GenericShellBolt"</span></div><div class="line"><span class="attr">    constructorArgs:</span></div><div class="line">      <span class="comment"># 命令行</span></div><div class="line"><span class="bullet">      -</span> [<span class="string">"python"</span>, <span class="string">"splitsentence.py"</span>]</div><div class="line">      <span class="comment"># 输出 fields</span></div><div class="line"><span class="bullet">      -</span> [<span class="string">"word"</span>]</div><div class="line"><span class="attr">    parallelism:</span> <span class="number">1</span></div><div class="line"></div><div class="line"><span class="attr">  - id:</span> <span class="string">"log"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.flux.wrappers.bolts.LogInfoBolt"</span></div><div class="line"><span class="attr">    parallelism:</span> <span class="number">1</span></div><div class="line"></div><div class="line"><span class="attr">  - id:</span> <span class="string">"count"</span></div><div class="line"><span class="attr">    className:</span> <span class="string">"org.apache.storm.testing.TestWordCounter"</span></div><div class="line"><span class="attr">    parallelism:</span> <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment"># 流定义</span></div><div class="line"><span class="comment"># 流定义就是定义 spouts 和 bolts 之间的连接</span></div><div class="line"><span class="comment"># 注意这种连接可以是周期性的</span></div><div class="line"><span class="comment"># 自定义流分组也是支持的</span></div><div class="line"></div><div class="line"><span class="attr">streams:</span></div><div class="line"><span class="attr">  - name:</span> <span class="string">"spout --&gt; split"</span> <span class="comment"># 名称目前没有被使用 (logging、UI 等的占位符)</span></div><div class="line"><span class="attr">    from:</span> <span class="string">"sentence-spout"</span></div><div class="line"><span class="attr">    to:</span> <span class="string">"splitsentence"</span></div><div class="line"><span class="attr">    grouping:</span></div><div class="line"><span class="attr">      type:</span> SHUFFLE</div><div class="line"></div><div class="line"><span class="attr">  - name:</span> <span class="string">"split --&gt; count"</span></div><div class="line"><span class="attr">    from:</span> <span class="string">"splitsentence"</span></div><div class="line"><span class="attr">    to:</span> <span class="string">"count"</span></div><div class="line"><span class="attr">    grouping:</span></div><div class="line"><span class="attr">      type:</span> FIELDS</div><div class="line"><span class="attr">      args:</span> [<span class="string">"word"</span>]</div><div class="line"></div><div class="line"><span class="attr">  - name:</span> <span class="string">"count --&gt; log"</span></div><div class="line"><span class="attr">    from:</span> <span class="string">"count"</span></div><div class="line"><span class="attr">    to:</span> <span class="string">"log"</span></div><div class="line"><span class="attr">    grouping:</span></div><div class="line"><span class="attr">      type:</span> SHUFFLE</div></pre></td></tr></table></figure>
<h2 id="微批处理-Trident-API"><a href="#微批处理-Trident-API" class="headerlink" title="微批处理 (Trident) API"></a>微批处理 (Trident) API</h2><p>目前，Flux YAML DSL 只支持 Storm 核心 API，但对 Storm 微批处理的 API 支持在计划中。</p>
<p>如果在 Trident topology 中使用 Flux ，可以定义一个 topology getter 方法，在 YAML 配置中引用它：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">name:</span> <span class="string">"my-trident-topology"</span></div><div class="line"></div><div class="line"><span class="attr">config:</span></div><div class="line">  topology.workers: <span class="number">1</span></div><div class="line"></div><div class="line"><span class="attr">topologySource:</span></div><div class="line"><span class="attr">  className:</span> <span class="string">"org.apache.storm.flux.test.TridentTopologySource"</span></div><div class="line">  <span class="comment"># Flux 默认将会调用 "getTopology" 方法，下列方法名会覆盖它。</span></div><div class="line"><span class="attr">  methodName:</span> <span class="string">"getTopologyWithDifferentMethodName"</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个用于简化 Apache Storm 流式计算任务创建和部署的框架&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;flux&lt;/strong&gt; |fləks| &lt;em&gt;noun&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;流入流出的动作或过程&lt;/li&gt;
&lt;li&gt;持续变化&lt;/li&gt;
&lt;li&gt;在物理学中，流体、辐射、微粒可以穿过一定的区域&lt;/li&gt;
&lt;li&gt;与固体物质混合，用来降低熔点&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h2&gt;&lt;p&gt;当配置是写死的时候总是会出现很多问题。不应该有人为了更改配置而重新编译或打包应用程序。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Flux 是一个用于简化创建和部署 Apache Storm Topologies 的框架和工具集。&lt;/p&gt;
    
    </summary>
    
      <category term="Storm" scheme="http://hk-lei.github.io/categories/Storm/"/>
    
      <category term="译文" scheme="http://hk-lei.github.io/categories/Storm/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="Storm" scheme="http://hk-lei.github.io/tags/Storm/"/>
    
      <category term="Flux" scheme="http://hk-lei.github.io/tags/Flux/"/>
    
  </entry>
  
  <entry>
    <title>Storm SQL 集成</title>
    <link href="http://hk-lei.github.io/2016/07/02/storm-sql/"/>
    <id>http://hk-lei.github.io/2016/07/02/storm-sql/</id>
    <published>2016-07-02T12:43:34.000Z</published>
    <updated>2016-08-03T13:04:58.408Z</updated>
    
    <content type="html"><![CDATA[<p>Storm SQL 集成允许用户在 Storm 流式数据中运行 SQL 查询。在流式分析中，SQL 接口不仅会加快开发周期，而且开辟了统一批处理 <a href="///hive.apache.org">Apache Hive</a> 和实时流式数据处理的机会。</p>
<p>StormSQL 会将 SQL 查询高水准的编译为 <a href="Trident-API-Overview.html">Trident</a> topologies 并且在 Storm 集群上允许他们。这篇文章将给用户介绍如何使用 StormSQL。如果有人对 StormSQL 的设计和实现的细节感兴趣，请参考 <a href="storm-sql-internal.html">这里</a></p>
<a id="more"></a>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>允许 <code>storm sql</code> 命令编译 SQL 语句为 Trident topology，并且提交到 Storm 集群。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/storm sql &lt;sql-file&gt; &lt;topo-name&gt;</div></pre></td></tr></table></figure>
<p>这里 <code>sql-file</code> 包含需要执行的 SQL 语句，<code>topo-name</code> 是提交的 topology 的名字。</p>
<h2 id="支持的功能"><a href="#支持的功能" class="headerlink" title="支持的功能"></a>支持的功能</h2><p>在目前的版本库(1.0.1)中，支持以下功能：</p>
<ul>
<li>流处理读取及写入外部数据源</li>
<li>过滤 tuples</li>
<li>预测（Projections）</li>
</ul>
<h2 id="指定外部数据源"><a href="#指定外部数据源" class="headerlink" title="指定外部数据源"></a>指定外部数据源</h2><p>StormSQL 数据是由外部表的形式表现的，用户可以使用 <code>CREATE EXTERNAL TABLE</code> 语句指定数据源。<code>CREATE EXTERNAL TABLE</code> 的语法严格遵循 <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL" target="_blank" rel="external">Hive Data Definition Language</a> 中的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE EXTERNAL TABLE table_name field_list</div><div class="line">    [ STORED AS</div><div class="line">      INPUTFORMAT input_format_classname</div><div class="line">      OUTPUTFORMAT output_format_classname</div><div class="line">    ]</div><div class="line">    LOCATION location</div><div class="line">    [ TBLPROPERTIES tbl_properties ]</div><div class="line">    [ AS select_stmt ]</div></pre></td></tr></table></figure>
<p>你可以在 <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL" target="_blank" rel="external">Hive Data Definition Language</a> 中找到各属性的详细解释。例如：下列语句指定了一个 Kafka spout 和 sink：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE EXTERNAL TABLE FOO (ID INT PRIMARY KEY) LOCATION &apos;kafka://localhost:2181/brokers?topic=test&apos; TBLPROPERTIES &apos;&#123;&quot;producer&quot;:&#123;&quot;bootstrap.servers&quot;:&quot;localhost:9092&quot;,&quot;acks&quot;:&quot;1&quot;,&quot;key.serializer&quot;:&quot;org.apache.org.apache.storm.kafka.IntSerializer&quot;,&quot;value.serializer&quot;:&quot;org.apache.org.apache.storm.kafka.ByteBufferSerializer&quot;&#125;&#125;&apos;</div></pre></td></tr></table></figure>
<h2 id="对接外部数据源"><a href="#对接外部数据源" class="headerlink" title="对接外部数据源"></a>对接外部数据源</h2><p>用户对接外部数据源需要实现 <code>ISqlTridentDataSource</code> 接口并且使用 Java 的服务加载机制注册他们，外部数据源就会基于表中 URI 的 Scheme 来选择。请参阅 <code>storm-sql-kafka</code> 来了解更多实现细节。</p>
<h2 id="示例-过滤-Kafka-数据流"><a href="#示例-过滤-Kafka-数据流" class="headerlink" title="示例: 过滤 Kafka 数据流"></a>示例: 过滤 Kafka 数据流</h2><p>假设有一个 Kafka 数据流存储交易的订单数据。流中的每个消息包含订单的 id 、产品的单价及订单的数量。我们的目的是过滤出有很大交易额的订单，将这些订单插入另一个 Kafka 数据流用于进行进一步分析。</p>
<p>用户可以在 SQL 文件中指定如下的 SQL 语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CREATE EXTERNAL TABLE ORDERS (ID INT PRIMARY KEY, UNIT_PRICE INT, QUANTITY INT) LOCATION &apos;kafka://localhost:2181/brokers?topic=orders&apos; TBLPROPERTIES &apos;&#123;&quot;producer&quot;:&#123;&quot;bootstrap.servers&quot;:&quot;localhost:9092&quot;,&quot;acks&quot;:&quot;1&quot;,&quot;key.serializer&quot;:&quot;org.apache.org.apache.storm.kafka.IntSerializer&quot;,&quot;value.serializer&quot;:&quot;org.apache.org.apache.storm.kafka.ByteBufferSerializer&quot;&#125;&#125;&apos;</div><div class="line">CREATE EXTERNAL TABLE LARGE_ORDERS (ID INT PRIMARY KEY, TOTAL INT) LOCATION &apos;kafka://localhost:2181/brokers?topic=large_orders&apos; TBLPROPERTIES &apos;&#123;&quot;producer&quot;:&#123;&quot;bootstrap.servers&quot;:&quot;localhost:9092&quot;,&quot;acks&quot;:&quot;1&quot;,&quot;key.serializer&quot;:&quot;org.apache.org.apache.storm.kafka.IntSerializer&quot;,&quot;value.serializer&quot;:&quot;org.apache.org.apache.storm.kafka.ByteBufferSerializer&quot;&#125;&#125;&apos;</div><div class="line">INSERT INTO LARGE_ORDERS SELECT ID, UNIT_PRICE * QUANTITY AS TOTAL FROM ORDERS WHERE UNIT_PRICE * QUANTITY &gt; 50</div></pre></td></tr></table></figure>
<p>第一条语句定义的 <code>ORDER</code> 表代表了输入流。 <code>LOCATION</code> 字段指定了 ZK 地址 (<code>localhost:2181</code>) 、brokers 在 Zookeeper 中的路径 (<code>/brokers</code>) 以及 topic (<code>orders</code>)。<code>TBLPROPERTIES</code> 字段指定了 <a href="http://kafka.apache.org/documentation.html#producerconfigs" target="_blank" rel="external">KafkaProducer</a> 的配置项。<br>目前 <code>storm-sql-kafka</code>的实现即使 table 是 read-only 或 write-only 情况都需要指定 <code>LOCATION</code> 和 <code>TBLPROPERTIES</code> 项。</p>
<p>类似的第二条语句定义的 <code>LARGE_ORDERS</code> 表代表了输出流。第三条 <code>SELECT</code> 语句定义了 topology : 其使 StormSQL 过滤外部表 <code>ORDERS</code> 中的所有订单(译注：过滤出总价在 50 以上的订单)，计算总价格并将满足的记录插入指定的 <code>LARGE_ORDER</code> Kafka 流中。</p>
<p>要运行这个示例，用户需要在 classpath 中包含数据源 (这个示例中是 <code>storm-sql-kafka</code>) 及其依赖。一种办法是将所需的 jars 放到 <code>extlib</code> 目录中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ cp curator-client-2.5.0.jar curator-framework-2.5.0.jar zookeeper-3.4.6.jar</div><div class="line"> extlib/</div><div class="line">$ cp scala-library-2.10.4.jar kafka-clients-0.8.2.1.jar kafka_2.10-0.8.2.1.jar metrics-core-2.2.0.jar extlib/</div><div class="line">$ cp json-simple-1.1.1.jar extlib/</div><div class="line">$ cp jackson-annotations-2.6.0.jar extlib/</div><div class="line">$ cp storm-kafka-*.jar storm-sql-kafka-*.jar storm-sql-runtime-*.jar extlib/</div></pre></td></tr></table></figure>
<p>接下来向 StormSQL 提交 SQL 语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/storm sql order_filtering order_filtering.sql</div></pre></td></tr></table></figure>
<p>现在你应该能够在 Storm UI 中看到 <code>order_filtering</code> topology。</p>
<h2 id="当前缺陷"><a href="#当前缺陷" class="headerlink" title="当前缺陷"></a>当前缺陷</h2><p>聚合(Aggregation)、 窗口(windowing)和连表(joining) 尚未实现；暂不支持指定 topology 的并行度；所有处理任务的并行度都是 1。</p>
<p>用户还需要在 <code>extlib</code> 目录中提供外部数据源的依赖，否则 topology 将因为 <code>ClassNotFoundException</code> 而无法运行。</p>
<p>StormSQL 中当前 Kafka 实现连接器假定输入和输出数据都是JSON格式。连接器还不支持 <code>INPUTFORMAT</code> 和 <code>OUTPUTFORMAT</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Storm SQL 集成允许用户在 Storm 流式数据中运行 SQL 查询。在流式分析中，SQL 接口不仅会加快开发周期，而且开辟了统一批处理 &lt;a href=&quot;///hive.apache.org&quot;&gt;Apache Hive&lt;/a&gt; 和实时流式数据处理的机会。&lt;/p&gt;
&lt;p&gt;StormSQL 会将 SQL 查询高水准的编译为 &lt;a href=&quot;Trident-API-Overview.html&quot;&gt;Trident&lt;/a&gt; topologies 并且在 Storm 集群上允许他们。这篇文章将给用户介绍如何使用 StormSQL。如果有人对 StormSQL 的设计和实现的细节感兴趣，请参考 &lt;a href=&quot;storm-sql-internal.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Storm" scheme="http://hk-lei.github.io/categories/Storm/"/>
    
      <category term="译文" scheme="http://hk-lei.github.io/categories/Storm/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="Storm" scheme="http://hk-lei.github.io/tags/Storm/"/>
    
      <category term="sql" scheme="http://hk-lei.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>HBase 集群备份</title>
    <link href="http://hk-lei.github.io/2015/04/21/HBase-%E9%9B%86%E7%BE%A4%E5%A4%87%E4%BB%BD/"/>
    <id>http://hk-lei.github.io/2015/04/21/HBase-集群备份/</id>
    <published>2015-04-21T07:13:00.000Z</published>
    <updated>2016-08-03T13:04:52.827Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注意：HBase 版本为 0.98.1</strong></p>
<h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>1 在 destination cluster 创建与 source cluster 中同名的 table 和 column families<br>2 确保 source cluster 和 destination cluster 可互通<br>3 在 source cluster 的 hbase-site.xml 中添加<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>4 在 source cluster 的 <code>hbase shell</code> 中使用 <code>add_peer</code> 添加 destination cluster:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hbase&gt; add_peer &apos;ID&apos; &apos;CLUSTER_KEY&apos;</div></pre></td></tr></table></figure></p>
<p><code>ID</code> 的条件: 必须为字符串，必须不包含连字符<br><code>CLUSTER_KEY</code> 的组成：<code>hbase.zookeeper.quorum:hbase.zookeeper.property.clientPort:zookeeper.znode.parent</code><br><a id="more"></a><br>5 在 source cluster，配置要备份的每个 column family：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hbase&gt; disable &apos;example_table&apos;</div><div class="line">hbase&gt; alter &apos;example_table&apos;, &#123;NAME =&gt; &apos;example_family&apos;, REPLICATION_SCOPE =&gt; &apos;1&apos;&#125;</div><div class="line">hbase&gt; enable &apos;example_table&apos;</div></pre></td></tr></table></figure></p>
<p>6 验证复制是否启动<br>检查 source cluster 上的日志是否有如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Considering 1 rs, with ratio 0.1</div><div class="line">Getting 1 rs from peer cluster # 0</div><div class="line">Choosing peer 10.10.1.49:62020</div></pre></td></tr></table></figure></p>
<p>7 验证复制的正确性<br>通过 HBase 内置的 <code>VerifyReplication</code> 的 MR Job：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hbase org.apache.hadoop.hbase.mapreduce.replication.VerifyReplication --starttime=&lt;timestamp&gt; --stoptime=&lt;timestamp&gt; --families=&lt;myFam&gt; &lt;ID&gt; &lt;tableName&gt;</div></pre></td></tr></table></figure></p>
<h3 id="CopyTable"><a href="#CopyTable" class="headerlink" title="CopyTable"></a>CopyTable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/hbase org.apache.hadoop.hbase.mapreduce.CopyTable [--starttime=X] [--endtime=Y] [--new.name=NEW] [--peer.adr=ADR] tablename</div></pre></td></tr></table></figure>
<p>例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hbase org.apache.hadoop.hbase.mapreduce.CopyTable --peer.adr=dstClusterZK:2181:/hbase --new.name=tableCopy tableOrig</div></pre></td></tr></table></figure></p>
<h3 id="Export-Import"><a href="#Export-Import" class="headerlink" title="Export/Import"></a>Export/Import</h3><p>1 Export<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/hbase org.apache.hadoop.hbase.mapreduce.Export &lt;tablename&gt; &lt;outputdir&gt; [&lt;versions&gt; [&lt;starttime&gt; [&lt;endtime&gt;]]]</div></pre></td></tr></table></figure></p>
<p>2 Import<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/hbase org.apache.hadoop.hbase.mapreduce.Import &lt;tablename&gt; &lt;inputdir&gt;</div></pre></td></tr></table></figure></p>
<p>3 ImportTsv<br>To load data via Puts:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.columns=a,b,c &lt;tablename&gt; &lt;hdfs-inputdir&gt;</div></pre></td></tr></table></figure></p>
<p>To generate StoreFiles for bulk-loading:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.columns=a,b,c -Dimporttsv.bulk.output=hdfs://storefile-outputdir &lt;tablename&gt; &lt;hdfs-data-inputdir&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><p>1 在 source cluster 的 hbase-site.xml 中添加如下配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.snapshot.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>2 创建 snapshot<br>该操作不用 disable table，几乎不会对 HBase 的性能产生影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ./bin/hbase shell</div><div class="line">hbase&gt; snapshot &apos;myTable&apos;, &apos;myTableSnapshot-122112&apos;</div></pre></td></tr></table></figure></p>
<p>若不想包含 flush data，使用如下参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hbase&gt; snapshot &apos;mytable&apos;, &apos;snapshot123&apos;, &#123;SKIP_FLUSH =&gt; true&#125;</div></pre></td></tr></table></figure></p>
<p>3 导入到 destination cluster<br>在 source cluster 上执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bin/hbase org.apache.hadoop.hbase.snapshot.ExportSnapshot -snapshot MySnapshot</div><div class="line">-copy-to hdfs://srv2:8082/hbase -mappers 16</div></pre></td></tr></table></figure></p>
<p>限制带宽：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bin/hbase org.apache.hadoop.hbase.snapshot.ExportSnapshot -snapshot MySnapshot</div><div class="line">-copy-to hdfs://srv2:8082/hbase -mappers 16 -bandwidth 200</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;注意：HBase 版本为 0.98.1&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;Replication&quot;&gt;&lt;a href=&quot;#Replication&quot; class=&quot;headerlink&quot; title=&quot;Replication&quot;&gt;&lt;/a&gt;Replication&lt;/h3&gt;&lt;p&gt;1 在 destination cluster 创建与 source cluster 中同名的 table 和 column families&lt;br&gt;2 确保 source cluster 和 destination cluster 可互通&lt;br&gt;3 在 source cluster 的 hbase-site.xml 中添加&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;hbase.replication&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;4 在 source cluster 的 &lt;code&gt;hbase shell&lt;/code&gt; 中使用 &lt;code&gt;add_peer&lt;/code&gt; 添加 destination cluster:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;hbase&amp;gt; add_peer &amp;apos;ID&amp;apos; &amp;apos;CLUSTER_KEY&amp;apos;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ID&lt;/code&gt; 的条件: 必须为字符串，必须不包含连字符&lt;br&gt;&lt;code&gt;CLUSTER_KEY&lt;/code&gt; 的组成：&lt;code&gt;hbase.zookeeper.quorum:hbase.zookeeper.property.clientPort:zookeeper.znode.parent&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="HBase" scheme="http://hk-lei.github.io/categories/HBase/"/>
    
    
      <category term="HBase" scheme="http://hk-lei.github.io/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>[译]Storm VS Samza</title>
    <link href="http://hk-lei.github.io/2015/04/15/Storm-VS-Samza/"/>
    <id>http://hk-lei.github.io/2015/04/15/Storm-VS-Samza/</id>
    <published>2015-04-15T10:30:38.000Z</published>
    <updated>2016-08-03T13:04:52.827Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>翻译自 <a href="http://samza.apache.org/learn/documentation/0.9/comparisons/storm.html" target="_blank" rel="external">Samza 官方文档</a>，翻译水平有限，若有错误之处，还请指正，感激不尽。</p>
</blockquote>
<p><a href="http://storm.apache.org/" target="_blank" rel="external">Storm</a> 和 Samza 非常相似，他们都提供了许多一样的高级特性：分区的流模型、分布式的执行环境、提供流式编程的 API、数据容错、对 Kafka 的集成等等。</p>
<p>Storm 和 Samza 针对相似的概念使用了不同的词语：Storm 中的 spouts 与 Samza 中的 stream consumers，bolts 与 tasks；tuples 与 messages。Storm 也有一些与 Samza 中不同的东西。</p>
<h3 id="排序与保障"><a href="#排序与保障" class="headerlink" title="排序与保障"></a>排序与保障</h3><p>Storm 允许你去选择你想要的数据保障级别：</p>
<ul>
<li><code>at-most-once</code>传输：这种机制在数据没有被正确处理或者机器进程出现故障时丢弃数据，这种机制没有复杂的逻辑处理，根据 spout 产生的数据依次处理</li>
<li><code>at-least-once</code>传输：其通过所有 提交的 tuple 的一个内存记录追踪每一个输入的 Tuple （及其下游的输出 Tuple）有没有在配置的时间内被成功处理，任何没有在超时时间内完全处理的 tuple 都会被重新提交。这种实现了一个 bolt 可能会多次处理相同的 tuple，也导致了消息的处理是无序的。这种机制也需要用户在其代码上的配合( 提供ack 和 fail方法)，其必须保持记录的祖先(tuple tree)，以便确认其 tuple 的输入，深入了解可参考 <a href="http://storm.apache.org/documentation/Guaranteeing-message-processing.html" target="_blank" rel="external">Storm 官方文档</a>。</li>
<li><code>exactly-once</code>语义：最后，Storm 通过 <a href="http://storm.apache.org/documentation/Trident-tutorial.html" target="_blank" rel="external">Trident</a> 的抽象实现了精确一次处理的语义。这种模式使用了同最少一次相同的容错机制。Tuples 被处理至少一次，但是 Storm 的 state 实现允许重复检测和忽略。（这种重复检测只适用于其 state 被 Storm 管理的情况，如果你的程序有副作用，例如发送消息到 Topology 之外的服务，他将不保证唯一一次的语义。）在这种模式下，Spout 将 输入流拆分成批次，其批次的处理按照严格的顺序执行</li>
</ul>
<a id="more"></a>
<p>Samza 也提供了保障机制——目前只有 <code>at-least-once</code> 传输，但是正在计划 <code>exactly-once</code>传输的支持。在每个流的分区内，Samza 始终按照输入流的顺序处理消息，但是不保证跨不同流和分区的消息顺序，这种模式使得 Samza 不用去追踪消息的上级输入而提供至少一次传输。在 Samza 中，虽然没有使用至多一次传输（例如，失败时丢弃消息）的性能优势，但是消息传输总是有保障的，这就是为什么 Samza 没有提供这种模式的原因。</p>
<p>此外，因为 Samza 在一个分区内处理的数据永远不会是无序的，所以其更适合去处理关键数据(keyed data)。举个例子：如果你有一个数据库的流式更新——此时，后一步更新操作也许会替换前一步更新操作——然后重新排序消息可能会导致最终的结果。对于在相同流分区中的对相同 key 的所有更新支持，Samza 能够保证一致的状态。</p>
<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>Storm 的 bolts 的 <code>lower-level API</code> 在流式处理中没有提供任何的状态管理。Bolt 可以保持一个 <code>in-memory state</code>（当 Bolt 死掉的时候会丢失），或者可以使用一个远程的数据库来存取状态。 然而，Topology 通常可以做到处理消息的速度远高于对远程数据库的调用速度，所以使得对于每一个消息的远程调用速度成为瓶颈。</p>
<p>对于其 <code>higher-level Trident API</code>，Storm 提供了<a href="http://storm.apache.org/documentation/Trident-state.html" target="_blank" rel="external">自动状态管理</a> 。其在内存中保存状态，并定期检查将其持久化到远程数据库中（如：Cassandra），所以对远程数据库访问的代价分摊到了数个处理 Tuples。通过保持元数据维护 state，Trident 能够实现 <code>exactly-once</code> 的处理语义。例如：如果你正在计算 Events，这种机制保证了 <code>counters</code>是正确的，即使出现机器的宕机或者 Tuples 的重新发送。</p>
<p>每个 Bolt 中 state 的大小较小的情况（也许少于 100K）下，Storm 缓存处理 state 的改变的方式可以工作的很好，这使得其使用于追踪计数器和指标的最大、最小及平均值及与之相似的情况。然而，如果你需要维持一个比较大的 state ，这种方式实际上会降低到每一个处理的 Tuple 都对数据库进行一次远程调用，从而增加其性能开销</p>
<p>Samza 使用了一个<a href="http://samza.apache.org/learn/documentation/0.9/container/state-management.html" target="_blank" rel="external">完全不同的方式管理状态</a>，每个 Samza task 在其本地机器上都包含一个嵌入式的 key-value 存储，而不是使用远程数据库持久化的方式。因此存取速度是非常快的，即使state 的大小大于其可用内存。改变此 key-value 存储复制到集群中的其他机器上，可以实现即使有机器宕机，之上正在运行的任务的状态可以在另一台机器恢复。</p>
<p>通过在同一台集群的存储和处理的协作，Samza 能够达到很高的吞吐量，即使维持比较大的 state 的时候。如果你想执行的不止是计数器状态操作的情况的话，这是必须的。例如：如果你想执行的是一个 window join 多个流的情况，或者一个流与一个数据库的表（通过更新日志传输到 Samza） join，或者几个相关的消息放入一个更大的消息，那么你需要保持这么多的状态，维持本地状态对 task 的执行更有效。</p>
<p>Samza 的状态管理的局限性是其目前还不支持 <code>exactly-once</code> 语义——目前只支持 <code>at-least-once</code>，但是目前我们正在努力修复这个曲线，敬请关注更新。</p>
<h3 id="分区和并行性"><a href="#分区和并行性" class="headerlink" title="分区和并行性"></a>分区和并行性</h3><p>Storm 的<a href="http://storm.apache.org/documentation/Understanding-the-parallelism-of-a-Storm-topology.html" target="_blank" rel="external">并行模式</a>和Samza的非常相似，两个框架都是将进程分割为独立的可并行执行的 tasks 中，资源是根据 tasks 的数量分配的：一个小的 Job 可以使所有的任务都运行在一个机器的一个进程中；一个大型的 job 可以将其任务分配到多个机器的多个进程中。</p>
<p>最大的不同是 Storm 默认法使用一个线程执行一个任务，而 Samza 使用一个单线程的处理机制（即容器机制）。一个 Samza 的容器可能包含多个任务，但是只有一个线程轮询每个任务，这就意味着每个容器恰好映射一个 CPU 核心，使资源模型更加简单并减少了在同一台机器上运行的其他任务的干扰。在一个不可预测的资源模型下，Storm 的多线程机制可以更加充分的利用机器的空闲资源。</p>
<p>Storm 支持动态均衡，也就是说给 Topology 添加更多线程或者进程不需要重启 Topology 或者 集群。这是一个方便的特性，尤其是在开发环境中。我们没有将其添加到 Samza 中：我们觉得这种更改需要通过一个正规的配置管理过程（如：版本控制、通知等），因为这会影响生产环境的性能。换句话说，jobs 的代码和配置应该完全代表其在集群之上运行的状态。</p>
<p>当使用 Trident 中的事物 spout （一个实现唯一一次处理的需求）时，并行性可能会潜在的降低。Trident 依赖对其所有输入流的一个全局的排序——这就是说需要对一个流的所有分区进行排序，不止在一个分区内。这就意味着该 Topology 的输入流都要经过一个 Spout 的实例，实际上忽略了输入流的分区机制。这个 Spout 可能会是大批量数据流的一个瓶颈。在 Samza 中所有流的处理都是并行的，因此没有这个瓶颈。</p>
<h3 id="部署和执行"><a href="#部署和执行" class="headerlink" title="部署和执行"></a>部署和执行</h3><p>Storm 集群的一部分节点运行着<code>Supervisor</code>守护进程。Supervisor 进程与一个运行 <code>Nimbus</code> 守护进程的 <code>Master</code> 节点进行通信。Nimbus 进程负责整个集群的工作分配和资源管理，详情可查看 <a href="http://storm.apache.org/documentation/Tutorial.html" target="_blank" rel="external">Strom’s Tutorial</a>。这与 YARN 非常相似，虽然 YARN 具备更多的功能、希望整合多框架，但 Nimbus 能够更好的与 Storm 集成。</p>
<p>Yahoo! 已经发布了 <a href="https://github.com/yahoo/storm-yarn" target="_blank" rel="external">Storm-YARN</a>。根据 Yahoo! 的<a href="https://developer.yahoo.com/blogs/ydn/storm-yarn-released-open-source-143745133.html" target="_blank" rel="external">博客</a>描述，Storm-YARN 是对在 YARN 上可启动一个单独的 Storm 集群 （包含完整的 Nimbus 和 Supervisors）的一层包装。</p>
<p>Storm 的 Nimbus 和 YARN 的 ResourceManager、Supervisor 和 NodeManager 存在着很多相同之处。与其写一个自己的资源管理框架，或者在 YARN 运行一个资源管理框架，我们决定 Samza 应该直接使用 YARN，并作为 YARN 生态系统中的一等公民。YARN 是稳定性好、利用率高、功能完备并可与 Hadoop 互操作的，同时他也提供了一些非常优秀的功能如：安全性（用户验证机制）、cgroup 级别的进程隔离等等。</p>
<p>Samza 在 YARN 中是可插拔的，所以如果你想使用一个不同的框架你可以替换他。</p>
<h3 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h3><p>Storm 是使用 Java 和 Clojure 开发的，但对非 JVM 语言提供了良好的支持，他遵循的模式和 MapReduce 的流模式非常相似： 非 JVM 语言的 task 运行在一个单独的进程中，数据发送到其标准输入，通过其标准输出读输出数据。</p>
<p>Samza 是使用 Java 和 Scala 开发的。他致力于多语言的支持，但目前只支持 JVM 语言。</p>
<h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>Storm 提供了在<a href="http://storm.apache.org/documentation/Tutorial.html" target="_blank" rel="external">代码</a>中建模 Topologies（多阶段的处理图）。Trident 在此之上提供了一个 <a href="http://storm.apache.org/documentation/Trident-API-Overview.html" target="_blank" rel="external">higher-level API</a>，包括关系处理如过滤、分组、聚合和连接等。这就意味着整个 Topology 是在一个地方被连接起来的，其优点是可以在代码中记录整个 Topology，但也有一个缺点：整个 Topology 的开发和部署是一个整体不可分离。</p>
<p>在 Samza 中，每一个 job 是一个独立的实体，你可以在一个项目中定义多个 job，也可以在不同团队的不同项目中定义不同的 job。每个 job 的启动、停止都是独立的， job 直接的交互只通过 stream 的命名，你可以在系统中添加 jobs ，这不会影响任何其他正在运行的 jobs，这使得 Samza 可以很好的适用于 大型公司的工作流之中。</p>
<p>Samza 的这种方式在 Storm 中可以使用一个代理(例如 Kafka)连接两个单独的 Topology 实现，但是 Storm 的 <code>exactly-once</code> 语义实现只能在单个 Topology 中有效。</p>
<h3 id="成熟度"><a href="#成熟度" class="headerlink" title="成熟度"></a>成熟度</h3><p>我们不能说 Storm 是成熟的，但是他有<a href="http://storm.apache.org/documentation/Powered-By.html" target="_blank" rel="external">大批的用户</a>、强大的功能集并且在积极的发展着。他与目前大部分消息系统（如 RabbitMQ、Kestrel、Kafka 等）集成的很好。</p>
<p>Samza 还处在发育期，但是其建立在强大的组成部件之上。YARN 相当年轻，但其在 Yahoo 已经跑在 3000+ 的集群之上，并且其项目在 <a href="http://hortonworks.com/" target="_blank" rel="external">Hortonworks</a> 和 <a href="http://www.cloudera.com/content/cloudera/en/home.html" target="_blank" rel="external">Cloudera</a> 的支持下积极的发展着。Kafka 有很强大的一面，并且有越来越多的<a href="https://cwiki.apache.org/confluence/display/KAFKA/Powered+By" target="_blank" rel="external">用户量</a>，其经常与 Storm 一起使用。Samza 是 LinkedIn 开源的一个新的标志性项目，我们希望其他人会发现其优点，被采用他。</p>
<h3 id="缓存机制和延迟性"><a href="#缓存机制和延迟性" class="headerlink" title="缓存机制和延迟性"></a>缓存机制和延迟性</h3><p>Storm 使用 <a href="http://zeromq.org/" target="_blank" rel="external">ZeroMQ</a> (注：0.9 版本之后开始使用 <a href="http://netty.io/" target="_blank" rel="external">Netty</a>)实现 bolt 间的非持久通信，其能够保证 tuples 传输具有极低的延迟性。Samza 不具备这种等效机制，其始终将任务的输入写入到流中。</p>
<p>另一方面，当 bolt 使用 ZeroMQ 发送消息时，消息消费者的消费速度不够快，生产者的 ZeroMQ 的缓存开始填充消息，当缓存量增大到一定程度后，Topology 的消息处理可能会超时，这会导致消息的重新发送、缓存数据量更大从而使问题更糟。为了阻止这种情况发送，你可以是设置同一时间 Topology 处理消息量的最大值，一旦达到这个阈值，Spout 会阻塞直到有消息已经处理成功。这种机制允许<code>back pressure</code>，但是需要小心设置<a href="http://nathanmarz.github.io/storm/doc/backtype/storm/Config.html#TOPOLOGY_MAX_SPOUT_PENDING" target="_blank" rel="external">topology.max.spout.pending</a>参数。如果一个 bolt 处理缓慢，他会拖垮整个 Topology。</p>
<p>bolts 这件缺乏代理也会使得给处理容错和消息语义增加复杂性。Storm 有一个 <a href="http://storm.apache.org/documentation/Guaranteeing-message-processing.html" target="_blank" rel="external">非常聪明机制</a> 检测失败的 Tuples。因为每个输入输出流都是有容错和副本机制的，所以 Samza 不需要这样的机制。</p>
<p>Samza 对于缓存使用不同的方式，我们将 StreamTask 间的每一个 hop 缓存到磁盘上。关于这个决定及其取舍的详细可参见 <a href="http://samza.apache.org/learn/documentation/0.9/comparisons/introduction.html" target="_blank" rel="external">Comparison Introduction</a>。这个设计方案使其更容易保证数据持久化，并且在一个 job 的处理存在高延迟的情况有可以缓存大量消息的优势。但是，这也带来了较高的延迟。</p>
<p>如上面的工作流中的描述，Samza 可以模仿 Storm，但会带来一些功能的丧失。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>Storm 支持标准的 UNIX 进程级别的管理，如果存在过高的 CPU、磁盘、网络或者内存的使用，你的 Topology 可能会影响另一个 Topology 的性能（反之亦然）。</p>
<p>Samza 使用 YARN 提供的资源基本的隔离，目前，YARN 支持 CPU 和 内存限制（通过 <a href="http://samza.apache.org/learn/documentation/0.9/yarn/isolation.html" target="_blank" rel="external">cgroups</a>）的显示控制，并且都已经成功的运用于 Samza。目前 Yarn 不支持对磁盘和网络的隔离。</p>
<h3 id="DRPC"><a href="#DRPC" class="headerlink" title="DRPC"></a>DRPC</h3><p>在 Storm 中，你可以写的 Topologies 不止可以接受固定的输入事件流，也可以根据需求允许客户端执行分布式计算，该请求在一个特殊的 Spout 中做为一个 Tuple 被发送到 Topology 中，在 Topology 的计算结果被返回到客户端（同步等待结果），这种机制被称为<a href="http://storm.apache.org/documentation/Distributed-RPC.html" target="_blank" rel="external">分布式 RPC</a>（DRPC）。</p>
<p>Samza 目前不具备 DRPC 的 API，但你可以使用 Samza 流处理原语建立它。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>Storm 将所有消息使用其定义的Tuple数据模型和可插拔的序列化机制</p>
<p>Samza 的数据模型和序列化机制都是可插拔的，这里我们不固执己见说哪一种更好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译自 &lt;a href=&quot;http://samza.apache.org/learn/documentation/0.9/comparisons/storm.html&quot;&gt;Samza 官方文档&lt;/a&gt;，翻译水平有限，若有错误之处，还请指正，感激不尽。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://storm.apache.org/&quot;&gt;Storm&lt;/a&gt; 和 Samza 非常相似，他们都提供了许多一样的高级特性：分区的流模型、分布式的执行环境、提供流式编程的 API、数据容错、对 Kafka 的集成等等。&lt;/p&gt;
&lt;p&gt;Storm 和 Samza 针对相似的概念使用了不同的词语：Storm 中的 spouts 与 Samza 中的 stream consumers，bolts 与 tasks；tuples 与 messages。Storm 也有一些与 Samza 中不同的东西。&lt;/p&gt;
&lt;h3 id=&quot;排序与保障&quot;&gt;&lt;a href=&quot;#排序与保障&quot; class=&quot;headerlink&quot; title=&quot;排序与保障&quot;&gt;&lt;/a&gt;排序与保障&lt;/h3&gt;&lt;p&gt;Storm 允许你去选择你想要的数据保障级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;at-most-once&lt;/code&gt;传输：这种机制在数据没有被正确处理或者机器进程出现故障时丢弃数据，这种机制没有复杂的逻辑处理，根据 spout 产生的数据依次处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;at-least-once&lt;/code&gt;传输：其通过所有 提交的 tuple 的一个内存记录追踪每一个输入的 Tuple （及其下游的输出 Tuple）有没有在配置的时间内被成功处理，任何没有在超时时间内完全处理的 tuple 都会被重新提交。这种实现了一个 bolt 可能会多次处理相同的 tuple，也导致了消息的处理是无序的。这种机制也需要用户在其代码上的配合( 提供ack 和 fail方法)，其必须保持记录的祖先(tuple tree)，以便确认其 tuple 的输入，深入了解可参考 &lt;a href=&quot;http://storm.apache.org/documentation/Guaranteeing-message-processing.html&quot;&gt;Storm 官方文档&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exactly-once&lt;/code&gt;语义：最后，Storm 通过 &lt;a href=&quot;http://storm.apache.org/documentation/Trident-tutorial.html&quot;&gt;Trident&lt;/a&gt; 的抽象实现了精确一次处理的语义。这种模式使用了同最少一次相同的容错机制。Tuples 被处理至少一次，但是 Storm 的 state 实现允许重复检测和忽略。（这种重复检测只适用于其 state 被 Storm 管理的情况，如果你的程序有副作用，例如发送消息到 Topology 之外的服务，他将不保证唯一一次的语义。）在这种模式下，Spout 将 输入流拆分成批次，其批次的处理按照严格的顺序执行&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Samza" scheme="http://hk-lei.github.io/categories/Samza/"/>
    
    
      <category term="Storm" scheme="http://hk-lei.github.io/tags/Storm/"/>
    
      <category term="Samza" scheme="http://hk-lei.github.io/tags/Samza/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 之 Camus: Kafka Hadoop Consumer</title>
    <link href="http://hk-lei.github.io/2015/04/08/Kafka-%E4%B9%8B-Camus-Kafka-Hadoop-Consumer/"/>
    <id>http://hk-lei.github.io/2015/04/08/Kafka-之-Camus-Kafka-Hadoop-Consumer/</id>
    <published>2015-04-08T06:26:27.000Z</published>
    <updated>2016-08-03T13:04:52.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>Camus 是一个 LinkedIn 开源的消费 Kafka 数据到 HDFS 的项目，其使用 MapReduce 实现此功能，源码托管在 <a href="https://github.com/linkedin/camus" target="_blank" rel="external">Github</a>之上，官方给出的架构图如下图所示。 </p>
<p><center><img src="/images/camus.jpg" alt="图1 Camus 官方架构图"></center><br>其实现的功能如下：</p>
<ul>
<li>管理自己消费的 Offset ，存储在 HDFS 之上</li>
<li>数据存储可根据时间分区<a id="more"></a>
<h3 id="2-入门"><a href="#2-入门" class="headerlink" title="2 入门"></a>2 入门</h3>要使用 Camus 需要做的事有以下几点：</li>
</ul>
<ol>
<li>根据自己的 Hadoop 和 Kafka 环境修改 pom 文件中的相应版本</li>
<li>根据 Kafka 的数据选择使用decoder 的类，官方提供的只有 Avro: KafkaAvroMessageDecoder 和 JSON: JsonStringMessageDecoder，若不满足需求，则需要编写继承 MessageDecoder 的自定义实现</li>
<li>把消费的消息格式化写入到 HDFS 中，官方提供了AvroRecordWriterProvider 和 StringRecordWriterProvider 类可选，若要自定义则需要编写继承 RecordWriterProvider 类的实现</li>
<li>在 camus.properties 中配置 Camus Job 需要的配置信息</li>
<li>使用 mvn clean package 构建项目，若要忽略测试可使用 -DskipTests 参数</li>
<li>提交到 Hadoop 集群运行<br>(待续)</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;1 简介&lt;/h3&gt;&lt;p&gt;Camus 是一个 LinkedIn 开源的消费 Kafka 数据到 HDFS 的项目，其使用 MapReduce 实现此功能，源码托管在 &lt;a href=&quot;https://github.com/linkedin/camus&quot;&gt;Github&lt;/a&gt;之上，官方给出的架构图如下图所示。 &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;/images/camus.jpg&quot; alt=&quot;图1 Camus 官方架构图&quot;&gt;&lt;/center&gt;&lt;br&gt;其实现的功能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理自己消费的 Offset ，存储在 HDFS 之上&lt;/li&gt;
&lt;li&gt;数据存储可根据时间分区
    
    </summary>
    
      <category term="Kafka" scheme="http://hk-lei.github.io/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://hk-lei.github.io/tags/Kafka/"/>
    
      <category term="ETL" scheme="http://hk-lei.github.io/tags/ETL/"/>
    
      <category term="Hadoop" scheme="http://hk-lei.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 之 The New Producer</title>
    <link href="http://hk-lei.github.io/2015/04/07/Kafka-%E4%B9%8B-The-New-Producer/"/>
    <id>http://hk-lei.github.io/2015/04/07/Kafka-之-The-New-Producer/</id>
    <published>2015-04-07T07:14:39.000Z</published>
    <updated>2016-08-03T13:04:52.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>kafka在 0.8.2.0 版本的时候将客户端的 jar 包分离了出来，重构了生产者的 API(Consumer client redesign 预计到 0.9 版本完成)，官方解释如下：</p>
<ul>
<li>As of the 0.8.2 release we encourage all new development to use the new Java producer. This client is production tested and generally both faster and more fully featured than the previous Scala client.</li>
</ul>
<p>maven 源如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>API参见<a href="http://kafka.apache.org/082/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html" target="_blank" rel="external">javadocs</a><br><a id="more"></a></p>
<h3 id="2-Producer-配置"><a href="#2-Producer-配置" class="headerlink" title="2 Producer 配置"></a>2 Producer 配置</h3><p>该 jar 包中提供的 KafkaProducer 可在创建其实例的时候在构造方法中指定配置集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">KafkaProducer</span><span class="params">(Properties properties)</span></span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="title">KafkaProducer</span><span class="params">(Map&lt;String, Object&gt; configs)</span></div></pre></td></tr></table></figure></p>
<p>也可将消息中的key、value的序列化机制在其构造方法中指定：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">KafkaProducer</span><span class="params">(Map&lt;String, Object&gt; configs, Serializer&lt;K&gt; keySerializer, Serializer&lt;V&gt; valueSerializer)</span></span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="title">KafkaProducer</span><span class="params">(Properties properties, Serializer&lt;K&gt; keySerializer, Serializer&lt;V&gt; valueSerializer)</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="title">KafkaProducer</span><span class="params">(ProducerConfig config, Serializer&lt;K&gt; keySerializer, Serializer&lt;V&gt; valueSerializer)</span></div></pre></td></tr></table></figure></p>
<p>配置项在该 jar 包中变化较大，常用项的几个变化为：</p>
<ul>
<li>metadata.broker.list 变为 bootstrap.servers</li>
<li>serializer.class 分为了 key.serializer 和 value.serializer</li>
<li>没有了 partitioner.class 配置</li>
<li>request.required.acks 变为了 acks 其值由之前的 0/1/-1 变为了 0/1/all</li>
</ul>
<p>配置项简介：<br><code>bootstrap.servers</code>: Kafka 的集群 broker servers 地址列表（IP:port，逗号分隔）<br><code>key.serializer</code>: 消息键的序列化类名<br><code>value.serializer</code>: 消息值的序列化类名<br><code>acks</code>: 表示生产者发送一条消息后的等待机制：<br>(1) <code>0</code>表示不等待，生产者不等待任何 server 的反馈，这种情况下<code>retries</code>配置项不生效，生产者也不知道消息是否成功<br>(2) <code>1</code>表示 leader 不等待 follower 复制成功反馈，将消息成功写到自己的本地日志后立即反馈给生产者，这种情况下如果 leader 刚反馈结束立即崩溃，没有一个 follower 复制成功，则该条记录丢失<br>(3) <code>all</code> 表示 leader 等待所有 follower 复制成功后才反馈给生产者，这种情况下可以保证在服务器不出现问题的情况下所有消息都不丢失，但是效率也是最差的。</p>
<p>其他的配置项详见：<code>org.apache.kafka.clients.producer.ProducerConfig</code></p>
<h3 id="3-消息-ProducerRecord"><a href="#3-消息-ProducerRecord" class="headerlink" title="3 消息 ProducerRecord"></a>3 消息 ProducerRecord</h3><p>创建消息<br>KafkaProducer 发送的消息被抽象为 <code>record</code> ：<code>ProducerRecord&lt;K, V&gt;</code><br>创建 <code>record</code> 的构造方法有以下三种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic, V value)</span></span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic, K key, V value)</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic, Integer partition, K key, V value)</span></div></pre></td></tr></table></figure></p>
<p>在<code>record</code>中可以指定目标分区；如果不被指定，那么默认使用的是基于 key 的 hash 值得默认分区；如果不指定分区也无 key ，则使用的是循环使用可用分区生产。<br>发送消息<br>发送一个<code>record</code> KafkaProducer 提供了两个方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K,V&gt; record)</span></span></div><div class="line"></div><div class="line"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K,V&gt; record, Callback callback)</span></div></pre></td></tr></table></figure></p>
<p>第一种异步方式 send record 等同于 send(record, null);<br>第二种异步方式 send record，同时可以传递一个回调函数，使其在返回 metadata 或抛出异常的时候执行回调 <code>callback</code> ，示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, <span class="string">"key"</span>, <span class="string">"value"</span>);</div><div class="line">producer.send(record, (RecordMetadata metadata, Exception e) -&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">        e.printStackTrace();</div><div class="line">    System.out.println(<span class="string">"The msg is:"</span> + msg + <span class="string">", It's partition is: "</span> </div><div class="line">                        + metadata.partition() + <span class="string">", It's offset is "</span> + metadata.offset());</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>send 方法返回的是<code>Future&lt;RecordMetadata&gt;</code>对象，可以根据其<code>get</code>方法获取 record 的 <code>RecordMetadata</code> 对象，其包含了 <code>partition</code> 及 <code>offset</code> 信息，示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, <span class="string">"key"</span>, <span class="string">"value"</span>);</div><div class="line">RecordMetadata recordMetadata = producer.send(record).get();</div><div class="line">System.out.println(<span class="string">"record : "</span> + msg + <span class="string">" - partition : "</span> + </div><div class="line">                    recordMetadata.partition() + <span class="string">" - offset :"</span> + recordMetadata.offset());</div></pre></td></tr></table></figure></p>
<h3 id="4-KafkaProducer-完整示例"><a href="#4-KafkaProducer-完整示例" class="headerlink" title="4 KafkaProducer 完整示例"></a>4 KafkaProducer 完整示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.xingxing.kafka;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.RecordMetadata;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Properties;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleProducer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> KafkaProducer&lt;String, String&gt; producer;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleProducer</span><span class="params">()</span> </span>&#123;</div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"x.x.x.x:9092, x.x.x.x:9092, x.x.x.x:9092"</span>);</div><div class="line">        props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</div><div class="line">        props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</div><div class="line">        props.put(<span class="string">"acks"</span>, <span class="string">"1"</span>); <span class="comment">//0 1 all</span></div><div class="line">        producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span> || args.length ==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Please provide topic name and Message count as arguments!"</span>);</div><div class="line">        &#125;</div><div class="line">        String topic = args[<span class="number">0</span>];</div><div class="line">        String count = args[<span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> messageCount = Integer.parseInt(count);</div><div class="line">        System.out.println(<span class="string">"Topic Name - "</span> + topic);</div><div class="line">        System.out.println(<span class="string">"Message Count - "</span> + messageCount);</div><div class="line">        SimpleProducer producer = <span class="keyword">new</span> SimpleProducer();</div><div class="line">        producer.sendMessage(topic, messageCount);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String topic, <span class="keyword">int</span> messageCount)</span> </span></div><div class="line">                <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mCount = <span class="number">0</span>; mCount &lt; messageCount; mCount ++) &#123;</div><div class="line">            Long runtime = System.currentTimeMillis();</div><div class="line">            String msg = <span class="string">"Message Publishing Time - "</span> + runtime;</div><div class="line">            ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, msg);</div><div class="line">            RecordMetadata recordMetadata = producer.send(record).get();</div><div class="line">            System.out.println(<span class="string">"record : "</span> + msg + <span class="string">" - partition : "</span> </div><div class="line">                    + recordMetadata.partition() + <span class="string">" - offset :"</span> + recordMetadata.offset());</div><div class="line">        &#125;</div><div class="line">        producer.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-MockProducer"><a href="#5-MockProducer" class="headerlink" title="5 MockProducer"></a>5 MockProducer</h3><p>客户端的jar中给出了一个测试接口 <code>MockProducer</code>，官方给出的解释：</p>
<ul>
<li>A mock of the producer interface you can use for testing code that uses Kafka.</li>
<li>By default this mock will synchronously complete each send call successfully. However it can be configured to allow the user to control the completion of the call and supply an optional error for the producer to throw.</li>
</ul>
<p>主要功能详见<code>org.apache.kafka.clients.producer.MockProducer</code>类源码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;1 简介&lt;/h3&gt;&lt;p&gt;kafka在 0.8.2.0 版本的时候将客户端的 jar 包分离了出来，重构了生产者的 API(Consumer client redesign 预计到 0.9 版本完成)，官方解释如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As of the 0.8.2 release we encourage all new development to use the new Java producer. This client is production tested and generally both faster and more fully featured than the previous Scala client.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;maven 源如下：&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.kafka&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;kafka-clients&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;0.8.2.0&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;API参见&lt;a href=&quot;http://kafka.apache.org/082/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html&quot;&gt;javadocs&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Kafka" scheme="http://hk-lei.github.io/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://hk-lei.github.io/tags/Kafka/"/>
    
      <category term="BigData" scheme="http://hk-lei.github.io/tags/BigData/"/>
    
      <category term="消息队列" scheme="http://hk-lei.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="生产者" scheme="http://hk-lei.github.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>Scala 之 正则表达式</title>
    <link href="http://hk-lei.github.io/2015/04/05/Scala-%E4%B9%8B-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://hk-lei.github.io/2015/04/05/Scala-之-正则表达式/</id>
    <published>2015-04-05T07:10:32.000Z</published>
    <updated>2016-08-03T13:04:52.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Scala-中正则表达式的基本使用"><a href="#1-Scala-中正则表达式的基本使用" class="headerlink" title="1 Scala 中正则表达式的基本使用"></a>1 Scala 中正则表达式的基本使用</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">val</span> pattern = <span class="string">"(S|s)cala"</span>.r</div><div class="line">pattern: scala.util.matching.<span class="type">Regex</span> = (<span class="type">S</span>|s)cala</div><div class="line"></div><div class="line">scala&gt; <span class="keyword">val</span> str = <span class="string">"Scala is scalable and cool"</span></div><div class="line">str: <span class="type">String</span> = <span class="type">Scala</span> is scalable and cool</div><div class="line"></div><div class="line">scala&gt; println(pattern findFirstIn str)</div><div class="line"><span class="type">Some</span>(<span class="type">Scala</span>)</div><div class="line"></div><div class="line">scala&gt; println((pattern findAllIn str).mkString(<span class="string">", "</span>))</div><div class="line"><span class="type">Scala</span>, scala</div></pre></td></tr></table></figure>
<p>Scala 隐式的将 <code>String</code> 类型的字符串转换成了 <code>RichString</code> 类型，然后调用其 <code>r()</code> 方法返回一个 <code>Regex</code> 实例。如果正则中使用到了转义字符，最好使用原始字符串 如 “\d2:\d2:\d4” 最好使用 “””\d2:\d2:\d4”””<br>查找使用 findFirstIn、findAllIn 等，替换使用 replaceFirstIn、replaceAllIn等。<br><a id="more"></a></p>
<h3 id="2-把正则表达式当做提取器"><a href="#2-把正则表达式当做提取器" class="headerlink" title="2 把正则表达式当做提取器"></a>2 把正则表达式当做提取器</h3><p>Scala 的正则表达式就是提取器，所以可以在 <code>case</code> 表达式中使用。Scala 默认会把每一个放在括号里的匹配都展开到一个模式变量里。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(input: <span class="type">String</span>)&#123;</div><div class="line">    |   <span class="keyword">val</span> <span class="type">MatchStock</span> = <span class="string">""</span><span class="string">"^(.+):(\d*\.\d+)"</span><span class="string">""</span>.r</div><div class="line">    |   input <span class="keyword">match</span> &#123;</div><div class="line">    |     <span class="keyword">case</span> <span class="type">MatchStock</span>(<span class="string">"GOOG"</span>, price) =&gt; println(<span class="string">"Price of GOOG is "</span> + price)</div><div class="line">    |     <span class="keyword">case</span> <span class="type">MatchStock</span>(<span class="string">"IBM"</span>, price) =&gt; println(<span class="string">"Price of IBM is "</span> + price)</div><div class="line">    |     <span class="keyword">case</span> <span class="type">MatchStock</span>(symbol, price) =&gt; printf(<span class="string">"Price of %s is %s\n"</span>, symbol, price)</div><div class="line">    |     <span class="keyword">case</span> _ =&gt; println(<span class="string">"Not processing "</span> + input)</div><div class="line">    |   &#125;</div><div class="line">    | &#125;</div><div class="line">process: (input: <span class="type">String</span>)<span class="type">Unit</span></div><div class="line"></div><div class="line">scala&gt; process(<span class="string">"GOOG:320.88"</span>)</div><div class="line"><span class="type">Price</span> of <span class="type">GOOG</span> is <span class="number">320.88</span></div><div class="line"></div><div class="line">scala&gt; process(<span class="string">"IBM:88.88"</span>)</div><div class="line"><span class="type">Price</span> of <span class="type">IBM</span> is <span class="number">88.88</span></div><div class="line"></div><div class="line">scala&gt; process(<span class="string">"GE:30.88"</span>)</div><div class="line"><span class="type">Price</span> of <span class="type">GE</span> is <span class="number">30.88</span></div><div class="line"></div><div class="line">scala&gt; process(<span class="string">"GE:30"</span>)</div><div class="line"><span class="type">Not</span> processing <span class="type">GE</span>:<span class="number">30</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Scala-中正则表达式的基本使用&quot;&gt;&lt;a href=&quot;#1-Scala-中正则表达式的基本使用&quot; class=&quot;headerlink&quot; title=&quot;1 Scala 中正则表达式的基本使用&quot;&gt;&lt;/a&gt;1 Scala 中正则表达式的基本使用&lt;/h3&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;scala&amp;gt; &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; pattern = &lt;span class=&quot;string&quot;&gt;&quot;(S|s)cala&quot;&lt;/span&gt;.r&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;pattern: scala.util.matching.&lt;span class=&quot;type&quot;&gt;Regex&lt;/span&gt; = (&lt;span class=&quot;type&quot;&gt;S&lt;/span&gt;|s)cala&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scala&amp;gt; &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&quot;Scala is scalable and cool&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;str: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Scala&lt;/span&gt; is scalable and cool&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scala&amp;gt; println(pattern findFirstIn str)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;Scala&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scala&amp;gt; println((pattern findAllIn str).mkString(&lt;span class=&quot;string&quot;&gt;&quot;, &quot;&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;Scala&lt;/span&gt;, scala&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Scala 隐式的将 &lt;code&gt;String&lt;/code&gt; 类型的字符串转换成了 &lt;code&gt;RichString&lt;/code&gt; 类型，然后调用其 &lt;code&gt;r()&lt;/code&gt; 方法返回一个 &lt;code&gt;Regex&lt;/code&gt; 实例。如果正则中使用到了转义字符，最好使用原始字符串 如 “\d2:\d2:\d4” 最好使用 “””\d2:\d2:\d4”””&lt;br&gt;查找使用 findFirstIn、findAllIn 等，替换使用 replaceFirstIn、replaceAllIn等。&lt;br&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://hk-lei.github.io/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://hk-lei.github.io/tags/Scala/"/>
    
      <category term="正则表达式" scheme="http://hk-lei.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Scala 之 模式匹配</title>
    <link href="http://hk-lei.github.io/2015/04/05/Scala-%E4%B9%8B-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>http://hk-lei.github.io/2015/04/05/Scala-之-模式匹配/</id>
    <published>2015-04-05T06:43:51.000Z</published>
    <updated>2016-08-03T13:04:52.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-case-里的模式变量和常量"><a href="#1-case-里的模式变量和常量" class="headerlink" title="1 case 里的模式变量和常量:"></a>1 case 里的模式变量和常量:</h3><p>模式变量要以小写开头，模式常量要以大写开头<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</div><div class="line">    |   <span class="keyword">val</span> max = <span class="number">100</span></div><div class="line">    |   <span class="keyword">val</span> <span class="type">MIN</span> = <span class="number">0</span></div><div class="line">    |</div><div class="line">    |   <span class="function"><span class="keyword">def</span> <span class="title">process</span> </span>(input: <span class="type">Int</span>) &#123;</div><div class="line">    |   input <span class="keyword">match</span> &#123;</div><div class="line">    |     <span class="keyword">case</span> max =&gt; println (<span class="string">"Don't try this at home"</span>)</div><div class="line">    |     <span class="keyword">case</span> <span class="type">MIN</span> =&gt; println (<span class="string">"You matched min"</span>)</div><div class="line">    |     <span class="keyword">case</span> _ =&gt; println (<span class="string">"Unreachable !!"</span>)</div><div class="line">    |     &#125;</div><div class="line">    |   &#125;</div><div class="line">    | &#125;</div><div class="line">&lt;console&gt;:<span class="number">13</span>: warning: patterns after a variable pattern cannot <span class="keyword">match</span> (<span class="type">SLS</span> <span class="number">8.1</span><span class="number">.1</span>)</div><div class="line"><span class="type">If</span> you intended to <span class="keyword">match</span> against value max in <span class="class"><span class="keyword">class</span> <span class="title">Sample</span>, <span class="title">you</span> <span class="title">must</span> <span class="title">use</span> <span class="title">backticks</span>, <span class="title">like</span></span>: <span class="keyword">case</span> `max` =&gt;</div><div class="line">          <span class="keyword">case</span> max =&gt; println (<span class="string">"Don't try this at home"</span>)</div><div class="line">               ^</div><div class="line">&lt;console&gt;:<span class="number">14</span>: warning: unreachable code due to variable pattern <span class="symbol">'ma</span>x' on line <span class="number">13</span></div><div class="line">          <span class="keyword">case</span> <span class="type">MIN</span> =&gt; println (<span class="string">"You matched min"</span>)</div><div class="line">                              ^</div><div class="line">&lt;console&gt;:<span class="number">15</span>: warning: unreachable code due to variable pattern <span class="symbol">'ma</span>x' on line <span class="number">13</span></div><div class="line">          <span class="keyword">case</span> _ =&gt; println (<span class="string">"Unreachable !!"</span>)</div><div class="line">                            ^</div><div class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span></div></pre></td></tr></table></figure></p>
<p>上面的代码中，case 认为 <code>max</code> 是自己的语句内的局部变量，即使 Sample 中有一个同名的变量。使用 Sample 定义的 <code>max</code> 可显示的指定作用域：<code>this.max</code><br><a id="more"></a></p>
<h3 id="2-case-类的模式匹配"><a href="#2-case-类的模式匹配" class="headerlink" title="2 case 类的模式匹配"></a>2 case 类的模式匹配</h3><p>注意：<code>case-to-case</code> 的继承已经禁止了<br>示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span>(<span class="params"></span>)</span></div><div class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span></div><div class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span>(<span class="params"></span>)</span></div><div class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Orange</span></span></div><div class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params"></span>)</span></div><div class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></div><div class="line"></div><div class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">ThingsAcceptor</span> </span>&#123;</div><div class="line">    | <span class="function"><span class="keyword">def</span> <span class="title">acceptStuff</span></span>(thing: <span class="type">Any</span>) &#123;</div><div class="line">    |   thing <span class="keyword">match</span> &#123;</div><div class="line">    |     <span class="keyword">case</span> <span class="type">Apple</span>() =&gt; println(<span class="string">"Thanks for the Apple"</span>)</div><div class="line">    |     <span class="keyword">case</span> <span class="type">Orange</span>() =&gt; println(<span class="string">"Thanks for the Orange"</span>)</div><div class="line">    |     <span class="keyword">case</span> <span class="type">Book</span>() =&gt; println(<span class="string">"Thanks for the Book"</span>)</div><div class="line">    |     <span class="keyword">case</span> _ =&gt; println(<span class="string">"Excuse me, why did you send me a "</span> + thing)</div><div class="line">    |     &#125;</div><div class="line">    |   &#125;</div><div class="line">    | &#125;</div><div class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">ThingsAcceptor</span></span></div><div class="line"></div><div class="line">scala&gt; <span class="keyword">val</span> acceptor = <span class="keyword">new</span> <span class="type">ThingsAcceptor</span></div><div class="line">acceptor: <span class="type">ThingsAcceptor</span> = <span class="type">ThingsAcceptor</span>@<span class="number">130</span>d63be</div><div class="line">scala&gt; acceptor.acceptStuff(<span class="type">Apple</span>())</div><div class="line"><span class="type">Thanks</span> <span class="keyword">for</span> the <span class="type">Apple</span></div><div class="line">scala&gt; acceptor.acceptStuff(<span class="type">Orange</span>())</div><div class="line"><span class="type">Thanks</span> <span class="keyword">for</span> the <span class="type">Orange</span></div><div class="line">scala&gt; acceptor.acceptStuff(<span class="type">Book</span>())</div><div class="line"><span class="type">Thanks</span> <span class="keyword">for</span> the <span class="type">Book</span></div><div class="line">scala&gt; acceptor.acceptStuff(<span class="type">Book</span>)</div><div class="line"><span class="type">Excuse</span> me, why did you send me a <span class="type">Book</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-case-里的模式变量和常量&quot;&gt;&lt;a href=&quot;#1-case-里的模式变量和常量&quot; class=&quot;headerlink&quot; title=&quot;1 case 里的模式变量和常量:&quot;&gt;&lt;/a&gt;1 case 里的模式变量和常量:&lt;/h3&gt;&lt;p&gt;模式变量要以小写开头，模式常量要以大写开头&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;scala&amp;gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sample&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    |   &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; max = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    |   &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MIN&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    |&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    |   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;process&lt;/span&gt; &lt;/span&gt;(input: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    |   input &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    |     &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; max =&amp;gt; println (&lt;span class=&quot;string&quot;&gt;&quot;Don&#39;t try this at home&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    |     &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MIN&lt;/span&gt; =&amp;gt; println (&lt;span class=&quot;string&quot;&gt;&quot;You matched min&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    |     &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; _ =&amp;gt; println (&lt;span class=&quot;string&quot;&gt;&quot;Unreachable !!&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    |     &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    |   &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    | &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;console&amp;gt;:&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;: warning: patterns after a variable pattern cannot &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;SLS&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8.1&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;If&lt;/span&gt; you intended to &lt;span class=&quot;keyword&quot;&gt;match&lt;/span&gt; against value max in &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sample&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;you&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;must&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;backticks&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;like&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; `max` =&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; max =&amp;gt; println (&lt;span class=&quot;string&quot;&gt;&quot;Don&#39;t try this at home&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;               ^&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;console&amp;gt;:&lt;span class=&quot;number&quot;&gt;14&lt;/span&gt;: warning: unreachable code due to variable pattern &lt;span class=&quot;symbol&quot;&gt;&#39;ma&lt;/span&gt;x&#39; on line &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MIN&lt;/span&gt; =&amp;gt; println (&lt;span class=&quot;string&quot;&gt;&quot;You matched min&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                              ^&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;console&amp;gt;:&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;: warning: unreachable code due to variable pattern &lt;span class=&quot;symbol&quot;&gt;&#39;ma&lt;/span&gt;x&#39; on line &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; _ =&amp;gt; println (&lt;span class=&quot;string&quot;&gt;&quot;Unreachable !!&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            ^&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;defined &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sample&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的代码中，case 认为 &lt;code&gt;max&lt;/code&gt; 是自己的语句内的局部变量，即使 Sample 中有一个同名的变量。使用 Sample 定义的 &lt;code&gt;max&lt;/code&gt; 可显示的指定作用域：&lt;code&gt;this.max&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://hk-lei.github.io/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://hk-lei.github.io/tags/Scala/"/>
    
      <category term="模式匹配" scheme="http://hk-lei.github.io/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Scala 之 for 循环</title>
    <link href="http://hk-lei.github.io/2015/04/04/Scala-%E4%B9%8B-for-%E5%BE%AA%E7%8E%AF/"/>
    <id>http://hk-lei.github.io/2015/04/04/Scala-之-for-循环/</id>
    <published>2015-04-04T05:27:45.000Z</published>
    <updated>2016-08-03T13:04:52.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="通用语法表达式"><a href="#通用语法表达式" class="headerlink" title="通用语法表达式"></a>通用语法表达式</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>([pattern &lt;- generator; definition*]+; filter*)</div><div class="line">    [<span class="keyword">yield</span>] expression</div></pre></td></tr></table></figure>
<p><code>for</code> 表达式接受的参数包括一个或多个生成器， 0或多个定义， 还有 0 或多个过滤器（<code>filter</code>）。<code>yield</code>关键字是可选的，存在表示表达式返回一组值而不是一个<code>Unit</code>。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">val</span> result = <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">3</span>) <span class="keyword">yield</span> i * <span class="number">2</span></div><div class="line">result: scala.collection.immutable.<span class="type">IndexedSeq</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)</div></pre></td></tr></table></figure></p>
<p>幕后，Scala 会把<code>for</code> 表达式翻译成另外的一个表达式，其根据表达式的复杂度组合使用 <code>map()</code> 和 <code>filter()</code><br>上述表达式的<code>map</code>实现:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">val</span> result2 = (<span class="number">1</span> to <span class="number">3</span>) map (_ * <span class="number">2</span>)</div><div class="line">result2: scala.collection.immutable.<span class="type">IndexedSeq</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>加入过滤条件的示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">val</span> doubleEven = <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">5</span>; <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">yield</span> i * <span class="number">2</span></div><div class="line">doubleEven: scala.collection.immutable.<span class="type">IndexedSeq</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">4</span>, <span class="number">8</span>)</div></pre></td></tr></table></figure></p>
<p>上述语句可改写为以下形式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> doubleEven = <span class="keyword">for</span>&#123;</div><div class="line">    i &lt;- <span class="number">1</span> to <span class="number">5</span></div><div class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">yield</span> i * <span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>多重循环意味着多个生成器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">3</span>; j &lt;- <span class="number">4</span> to <span class="number">6</span>)</div><div class="line">     | print (<span class="string">"["</span> + i + <span class="string">", "</span> + j + <span class="string">"]"</span>)</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>][<span class="number">1</span>, <span class="number">5</span>][<span class="number">1</span>, <span class="number">6</span>][<span class="number">2</span>, <span class="number">4</span>][<span class="number">2</span>, <span class="number">5</span>][<span class="number">2</span>, <span class="number">6</span>][<span class="number">3</span>, <span class="number">4</span>][<span class="number">3</span>, <span class="number">5</span>][<span class="number">3</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;通用语法表达式&quot;&gt;&lt;a href=&quot;#通用语法表达式&quot; class=&quot;headerlink&quot; title=&quot;通用语法表达式&quot;&gt;&lt;/a&gt;通用语法表达式&lt;/h3&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;([pattern &amp;lt;- generator; definition*]+; filter*)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;] expression&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;for&lt;/code&gt; 表达式接受的参数包括一个或多个生成器， 0或多个定义， 还有 0 或多个过滤器（&lt;code&gt;filter&lt;/code&gt;）。&lt;code&gt;yield&lt;/code&gt;关键字是可选的，存在表示表达式返回一组值而不是一个&lt;code&gt;Unit&lt;/code&gt;。例如：&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;scala&amp;gt; &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; result = &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i &amp;lt;- &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; i * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;result: scala.collection.immutable.&lt;span class=&quot;type&quot;&gt;IndexedSeq&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;] = &lt;span class=&quot;type&quot;&gt;Vector&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;幕后，Scala 会把&lt;code&gt;for&lt;/code&gt; 表达式翻译成另外的一个表达式，其根据表达式的复杂度组合使用 &lt;code&gt;map()&lt;/code&gt; 和 &lt;code&gt;filter()&lt;/code&gt;&lt;br&gt;上述表达式的&lt;code&gt;map&lt;/code&gt;实现:&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;scala&amp;gt; &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; result2 = (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) map (_ * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;result2: scala.collection.immutable.&lt;span class=&quot;type&quot;&gt;IndexedSeq&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;] = &lt;span class=&quot;type&quot;&gt;Vector&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://hk-lei.github.io/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://hk-lei.github.io/tags/Scala/"/>
    
      <category term="for 循环" scheme="http://hk-lei.github.io/tags/for-%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 源码编译安装 Git</title>
    <link href="http://hk-lei.github.io/2015/04/02/CentOS-%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85-Git/"/>
    <id>http://hk-lei.github.io/2015/04/02/CentOS-源码编译安装-Git/</id>
    <published>2015-04-02T10:09:22.000Z</published>
    <updated>2016-08-03T13:04:52.826Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo yum install zlib expat libcurl gettext asciidoc</div></pre></td></tr></table></figure>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ unzip git-2.3.5.zip</div><div class="line">$ <span class="built_in">cd</span> git-2.3.5</div><div class="line"></div><div class="line">$ make configure</div><div class="line"></div><div class="line">$ ./configure --prefix=/usr</div><div class="line"></div><div class="line">$ make all doc info -j 16</div><div class="line"></div><div class="line">$ sudo make install install-doc install-html</div><div class="line"></div><div class="line">$ <span class="built_in">cd</span></div><div class="line">$ git version</div><div class="line">git version 2.3.5</div><div class="line"></div><div class="line"><span class="comment">#安装完成后删除源码及编译生成的文件</span></div><div class="line">$ sudo rm -rf /path/to/git-2.3.5*</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装依赖&quot;&gt;&lt;a href=&quot;#安装依赖&quot; class=&quot;headerlink&quot; title=&quot;安装依赖&quot;&gt;&lt;/a&gt;安装依赖&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
    
    </summary>
    
      <category term="Git" scheme="http://hk-lei.github.io/categories/Git/"/>
    
    
      <category term="CentOS" scheme="http://hk-lei.github.io/tags/CentOS/"/>
    
      <category term="Git" scheme="http://hk-lei.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://hk-lei.github.io/2015/04/01/hello-world/"/>
    <id>http://hk-lei.github.io/2015/04/01/hello-world/</id>
    <published>2015-04-01T10:01:02.000Z</published>
    <updated>2016-08-03T13:08:35.402Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;http://hexo.io/docs/writing.html&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo server&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
